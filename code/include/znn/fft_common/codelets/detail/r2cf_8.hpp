//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct r2cf_traits<8, 1>
{
    static constexpr long_t flops           = 0;
    static constexpr long_t operations      = 0;
    static constexpr long_t memory_accesses = 6;
    static constexpr long_t stack_vars      = 1;
    static constexpr long_t constants       = 0;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 1 -name r2cf
 * -standalone */

/*
 * This function contains 0 FP additions, 0 FP multiplications,
 * (or, 0 additions, 0 multiplications, 0 fused multiply/add),
 * 1 stack variables, 0 constants, and 6 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 1>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    {
        SIMD_FLOAT T1;
        T1            = R0[0];
        Cr[WS(cs, 3)] = T1;
        Cr[WS(cs, 2)] = T1;
        Cr[WS(cs, 1)] = T1;
        Cr[WS(cs, 4)] = T1;
        Cr[0]         = T1;
    }
}

template <>
struct r2cf_traits<8, 2>
{
    static constexpr long_t flops           = 8;
    static constexpr long_t operations      = 6;
    static constexpr long_t memory_accesses = 10;
    static constexpr long_t stack_vars      = 3;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 2 -name r2cf
 * -standalone */

/*
 * This function contains 4 FP additions, 4 FP multiplications,
 * (or, 2 additions, 2 multiplications, 2 fused multiply/add),
 * 3 stack variables, 1 constants, and 10 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 2>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T2;
        T1            = R0[0];
        T2            = R0[WS(rs, 1)];
        Cr[WS(cs, 2)] = T1;
        Cr[WS(cs, 4)] = T1 - T2;
        Cr[WS(cs, 1)] = SIMD_FMADD(KP707106781, T2, T1);
        Cr[0]         = T1 + T2;
        Cr[WS(cs, 3)] = SIMD_FNMADD(KP707106781, T2, T1);
        Ci[WS(cs, 3)] = -(KP707106781 * T2);
        Ci[WS(cs, 1)] = -(KP707106781 * T2);
        Ci[WS(cs, 2)] = -T2;
    }
}

template <>
struct r2cf_traits<8, 3>
{
    static constexpr long_t flops           = 12;
    static constexpr long_t operations      = 8;
    static constexpr long_t memory_accesses = 11;
    static constexpr long_t stack_vars      = 5;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 3 -name r2cf
 * -standalone */

/*
 * This function contains 8 FP additions, 4 FP multiplications,
 * (or, 4 additions, 0 multiplications, 4 fused multiply/add),
 * 5 stack variables, 1 constants, and 11 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 3>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T3, T1, T2, T4;
        T3            = R0[WS(rs, 1)];
        T1            = R0[0];
        T2            = R0[WS(rs, 2)];
        Ci[WS(cs, 2)] = -T3;
        Cr[WS(cs, 3)] = SIMD_FNMADD(KP707106781, T3, T1);
        Cr[WS(cs, 1)] = SIMD_FMADD(KP707106781, T3, T1);
        Ci[WS(cs, 3)] = SIMD_FNMADD(KP707106781, T3, T2);
        Ci[WS(cs, 1)] = -(SIMD_FMADD(KP707106781, T3, T2));
        Cr[WS(cs, 2)] = T1 - T2;
        T4            = T1 + T2;
        Cr[0]         = T4 + T3;
        Cr[WS(cs, 4)] = T4 - T3;
    }
}

template <>
struct r2cf_traits<8, 4>
{
    static constexpr long_t flops           = 14;
    static constexpr long_t operations      = 10;
    static constexpr long_t memory_accesses = 12;
    static constexpr long_t stack_vars      = 8;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 4 -name r2cf
 * -standalone */

/*
 * This function contains 10 FP additions, 4 FP multiplications,
 * (or, 6 additions, 0 multiplications, 4 fused multiply/add),
 * 8 stack variables, 1 constants, and 12 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 4>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T2, T4, T5, T3, T6, T7;
        T1            = R0[0];
        T2            = R0[WS(rs, 2)];
        T4            = R0[WS(rs, 1)];
        T5            = R0[WS(rs, 3)];
        Cr[WS(cs, 2)] = T1 - T2;
        T3            = T1 + T2;
        T6            = T4 + T5;
        T7            = T5 - T4;
        Cr[WS(cs, 3)] = SIMD_FMADD(KP707106781, T7, T1);
        Cr[WS(cs, 1)] = SIMD_FNMADD(KP707106781, T7, T1);
        Ci[WS(cs, 2)] = T7;
        Ci[WS(cs, 3)] = SIMD_FNMADD(KP707106781, T6, T2);
        Cr[0]         = T3 + T6;
        Ci[WS(cs, 1)] = -(SIMD_FMADD(KP707106781, T6, T2));
        Cr[WS(cs, 4)] = T3 - T6;
    }
}

template <>
struct r2cf_traits<8, 5>
{
    static constexpr long_t flops           = 16;
    static constexpr long_t operations      = 12;
    static constexpr long_t memory_accesses = 13;
    static constexpr long_t stack_vars      = 11;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 5 -name r2cf
 * -standalone */

/*
 * This function contains 12 FP additions, 4 FP multiplications,
 * (or, 8 additions, 0 multiplications, 4 fused multiply/add),
 * 11 stack variables, 1 constants, and 13 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 5>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T4, T6, T7, T1, T2, Ta, T8, T9, T3, T5;
        T4            = R0[WS(rs, 2)];
        T6            = R0[WS(rs, 1)];
        T7            = R0[WS(rs, 3)];
        T1            = R0[0];
        T2            = R0[WS(rs, 4)];
        Ta            = T7 - T6;
        T8            = T6 + T7;
        T9            = T1 - T2;
        T3            = T1 + T2;
        Ci[WS(cs, 2)] = Ta;
        Ci[WS(cs, 3)] = SIMD_FNMADD(KP707106781, T8, T4);
        Ci[WS(cs, 1)] = -(SIMD_FMADD(KP707106781, T8, T4));
        Cr[WS(cs, 3)] = SIMD_FMADD(KP707106781, Ta, T9);
        Cr[WS(cs, 1)] = SIMD_FNMADD(KP707106781, Ta, T9);
        T5            = T3 + T4;
        Cr[WS(cs, 2)] = T3 - T4;
        Cr[0]         = T5 + T8;
        Cr[WS(cs, 4)] = T5 - T8;
    }
}

template <>
struct r2cf_traits<8, 6>
{
    static constexpr long_t flops           = 20;
    static constexpr long_t operations      = 16;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 15;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 6 -name r2cf
 * -standalone */

/*
 * This function contains 16 FP additions, 4 FP multiplications,
 * (or, 12 additions, 0 multiplications, 4 fused multiply/add),
 * 15 stack variables, 1 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 6>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T4, T9, T1, T2, T6, T7, T3, T5, T8, Td, Tc, Te, Ta, Tb;
        T4            = R0[WS(rs, 2)];
        T9            = R0[WS(rs, 3)];
        T1            = R0[0];
        T2            = R0[WS(rs, 4)];
        T6            = R0[WS(rs, 1)];
        T7            = R0[WS(rs, 5)];
        T3            = T1 + T2;
        T5            = T1 - T2;
        T8            = T6 - T7;
        Td            = T6 + T7;
        Tc            = T3 + T4;
        Cr[WS(cs, 2)] = T3 - T4;
        Te            = Td + T9;
        Ci[WS(cs, 2)] = T9 - Td;
        Ta            = T8 - T9;
        Tb            = T8 + T9;
        Cr[0]         = Tc + Te;
        Cr[WS(cs, 4)] = Tc - Te;
        Ci[WS(cs, 3)] = SIMD_FNMADD(KP707106781, Tb, T4);
        Ci[WS(cs, 1)] = -(SIMD_FMADD(KP707106781, Tb, T4));
        Cr[WS(cs, 1)] = SIMD_FMADD(KP707106781, Ta, T5);
        Cr[WS(cs, 3)] = SIMD_FNMADD(KP707106781, Ta, T5);
    }
}

template <>
struct r2cf_traits<8, 7>
{
    static constexpr long_t flops           = 22;
    static constexpr long_t operations      = 18;
    static constexpr long_t memory_accesses = 15;
    static constexpr long_t stack_vars      = 18;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 7 -name r2cf
 * -standalone */

/*
 * This function contains 18 FP additions, 4 FP multiplications,
 * (or, 14 additions, 0 multiplications, 4 fused multiply/add),
 * 18 stack variables, 1 constants, and 15 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 7>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT Tb, T8, T9, T1, T2, T4, T5, Tg, Ta, T7, T3, Td, T6, Th, Te;
        SIMD_FLOAT Tc, Tf;
        Tb            = R0[WS(rs, 3)];
        T8            = R0[WS(rs, 1)];
        T9            = R0[WS(rs, 5)];
        T1            = R0[0];
        T2            = R0[WS(rs, 4)];
        T4            = R0[WS(rs, 2)];
        T5            = R0[WS(rs, 6)];
        Tg            = T8 + T9;
        Ta            = T8 - T9;
        T7            = T1 - T2;
        T3            = T1 + T2;
        Td            = T4 - T5;
        T6            = T4 + T5;
        Th            = Tg + Tb;
        Ci[WS(cs, 2)] = Tb - Tg;
        Te            = Ta + Tb;
        Tc            = Ta - Tb;
        Tf            = T3 + T6;
        Cr[WS(cs, 2)] = T3 - T6;
        Ci[WS(cs, 3)] = SIMD_FNMADD(KP707106781, Te, Td);
        Ci[WS(cs, 1)] = -(SIMD_FMADD(KP707106781, Te, Td));
        Cr[WS(cs, 1)] = SIMD_FMADD(KP707106781, Tc, T7);
        Cr[WS(cs, 3)] = SIMD_FNMADD(KP707106781, Tc, T7);
        Cr[0]         = Tf + Th;
        Cr[WS(cs, 4)] = Tf - Th;
    }
}

template <>
struct r2cf_traits<8, 8>
{
    static constexpr long_t flops           = 24;
    static constexpr long_t operations      = 20;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 21;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_r2cf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 8 -name r2cf
 * -standalone */

/*
 * This function contains 20 FP additions, 4 FP multiplications,
 * (or, 16 additions, 0 multiplications, 4 fused multiply/add),
 * 21 stack variables, 1 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 8>::type
r2cf(SIMD_FLOAT const* __restrict R0, SIMD_FLOAT* __restrict Cr,
     SIMD_FLOAT* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T2, Tb, Tc, T4, T5, T8, T9, T3, T7, Td, Tj, T6, Tf, Ta;
        SIMD_FLOAT Ti, Th, Tk, Te, Tg;
        T1            = R0[0];
        T2            = R0[WS(rs, 4)];
        Tb            = R0[WS(rs, 7)];
        Tc            = R0[WS(rs, 3)];
        T4            = R0[WS(rs, 2)];
        T5            = R0[WS(rs, 6)];
        T8            = R0[WS(rs, 1)];
        T9            = R0[WS(rs, 5)];
        T3            = T1 + T2;
        T7            = T1 - T2;
        Td            = Tb - Tc;
        Tj            = Tb + Tc;
        T6            = T4 + T5;
        Tf            = T4 - T5;
        Ta            = T8 - T9;
        Ti            = T8 + T9;
        Th            = T3 + T6;
        Cr[WS(cs, 2)] = T3 - T6;
        Tk            = Ti + Tj;
        Ci[WS(cs, 2)] = Tj - Ti;
        Te            = Ta + Td;
        Tg            = Td - Ta;
        Cr[0]         = Th + Tk;
        Cr[WS(cs, 4)] = Th - Tk;
        Ci[WS(cs, 3)] = SIMD_FMADD(KP707106781, Tg, Tf);
        Ci[WS(cs, 1)] = SIMD_FMSUB(KP707106781, Tg, Tf);
        Cr[WS(cs, 1)] = SIMD_FMADD(KP707106781, Te, T7);
        Cr[WS(cs, 3)] = SIMD_FNMADD(KP707106781, Te, T7);
    }
}
