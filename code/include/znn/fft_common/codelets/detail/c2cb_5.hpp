//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct c2cb_traits<5, 0>
{
    static constexpr long_t flops           = 50;
    static constexpr long_t operations      = 32;
    static constexpr long_t memory_accesses = 20;
    static constexpr long_t stack_vars      = 36;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 5 -skip-k 0 -name c2cb
 * -standalone */

/*
 * This function contains 32 FP additions, 18 FP multiplications,
 * (or, 14 additions, 0 multiplications, 18 fused multiply/add),
 * 36 stack variables, 4 constants, and 20 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 0>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP559016994, +0.559016994374947424102293417182819058860154590);
    DK(KP250000000, +0.250000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T1, Tl, T2, T3, T5, T6, Tc, Td, Tf, Tg, T4, Ts, T7, Tt, Tm;
        SIMD_FLOAT Te, Tn, Th, Tu, Tw, T8, Ta, Ti, Tk, Tq, To, T9, Tp, Tb, Tj;
        SIMD_FLOAT Tr, Tv;
        T1            = ri[0];
        Tl            = ii[0];
        T2            = ri[WS(is, 1)];
        T3            = ri[WS(is, 4)];
        T5            = ri[WS(is, 2)];
        T6            = ri[WS(is, 3)];
        Tc            = ii[WS(is, 1)];
        Td            = ii[WS(is, 4)];
        Tf            = ii[WS(is, 2)];
        Tg            = ii[WS(is, 3)];
        T4            = T2 + T3;
        Ts            = T2 - T3;
        T7            = T5 + T6;
        Tt            = T5 - T6;
        Tm            = Tc + Td;
        Te            = Tc - Td;
        Tn            = Tf + Tg;
        Th            = Tf - Tg;
        Tu            = SIMD_FMADD(KP618033988, Tt, Ts);
        Tw            = SIMD_FNMADD(KP618033988, Ts, Tt);
        T8            = T4 + T7;
        Ta            = T4 - T7;
        Ti            = SIMD_FMADD(KP618033988, Th, Te);
        Tk            = SIMD_FNMADD(KP618033988, Te, Th);
        Tq            = Tm - Tn;
        To            = Tm + Tn;
        T9            = SIMD_FNMADD(KP250000000, T8, T1);
        ro[0]         = T1 + T8;
        Tp            = SIMD_FNMADD(KP250000000, To, Tl);
        io[0]         = Tl + To;
        Tb            = SIMD_FMADD(KP559016994, Ta, T9);
        Tj            = SIMD_FNMADD(KP559016994, Ta, T9);
        Tr            = SIMD_FMADD(KP559016994, Tq, Tp);
        Tv            = SIMD_FNMADD(KP559016994, Tq, Tp);
        ro[WS(os, 2)] = SIMD_FNMADD(KP951056516, Tk, Tj);
        ro[WS(os, 3)] = SIMD_FMADD(KP951056516, Tk, Tj);
        ro[WS(os, 1)] = SIMD_FMADD(KP951056516, Ti, Tb);
        ro[WS(os, 4)] = SIMD_FNMADD(KP951056516, Ti, Tb);
        io[WS(os, 2)] = SIMD_FMADD(KP951056516, Tw, Tv);
        io[WS(os, 3)] = SIMD_FNMADD(KP951056516, Tw, Tv);
        io[WS(os, 4)] = SIMD_FMADD(KP951056516, Tu, Tr);
        io[WS(os, 1)] = SIMD_FNMADD(KP951056516, Tu, Tr);
    }
}

template <>
struct c2cb_traits<5, 1>
{
    static constexpr long_t flops           = 48;
    static constexpr long_t operations      = 30;
    static constexpr long_t memory_accesses = 18;
    static constexpr long_t stack_vars      = 36;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 5 -skip-k 1 -name c2cb
 * -standalone */

/*
 * This function contains 30 FP additions, 18 FP multiplications,
 * (or, 12 additions, 0 multiplications, 18 fused multiply/add),
 * 36 stack variables, 4 constants, and 18 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 1>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP559016994, +0.559016994374947424102293417182819058860154590);
    DK(KP250000000, +0.250000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T1, Tl, T2, T3, T5, T6, Tc, Td, Tf, Tg, T4, Ts, T7, Tt, Tm;
        SIMD_FLOAT Te, Tn, Th, Tu, Tw, T8, Ta, Ti, Tk, Tq, To, T9, Tp, Tb, Tj;
        SIMD_FLOAT Tr, Tv;
        T1            = ri[0];
        Tl            = ii[0];
        T2            = ri[WS(is, 1)];
        T3            = ri[WS(is, 4)];
        T5            = ri[WS(is, 2)];
        T6            = ri[WS(is, 3)];
        Tc            = ii[WS(is, 1)];
        Td            = ii[WS(is, 4)];
        Tf            = ii[WS(is, 2)];
        Tg            = ii[WS(is, 3)];
        T4            = T2 + T3;
        Ts            = T2 - T3;
        T7            = T5 + T6;
        Tt            = T5 - T6;
        Tm            = Tc + Td;
        Te            = Tc - Td;
        Tn            = Tf + Tg;
        Th            = Tf - Tg;
        Tu            = SIMD_FMADD(KP618033988, Tt, Ts);
        Tw            = SIMD_FNMADD(KP618033988, Ts, Tt);
        T8            = T4 + T7;
        Ta            = T4 - T7;
        Ti            = SIMD_FMADD(KP618033988, Th, Te);
        Tk            = SIMD_FNMADD(KP618033988, Te, Th);
        Tq            = Tm - Tn;
        To            = Tm + Tn;
        T9            = SIMD_FNMADD(KP250000000, T8, T1);
        Tp            = SIMD_FNMADD(KP250000000, To, Tl);
        Tb            = SIMD_FMADD(KP559016994, Ta, T9);
        Tj            = SIMD_FNMADD(KP559016994, Ta, T9);
        Tr            = SIMD_FMADD(KP559016994, Tq, Tp);
        Tv            = SIMD_FNMADD(KP559016994, Tq, Tp);
        ro[WS(os, 1)] = SIMD_FNMADD(KP951056516, Tk, Tj);
        ro[WS(os, 2)] = SIMD_FMADD(KP951056516, Tk, Tj);
        ro[0]         = SIMD_FMADD(KP951056516, Ti, Tb);
        ro[WS(os, 3)] = SIMD_FNMADD(KP951056516, Ti, Tb);
        io[WS(os, 1)] = SIMD_FMADD(KP951056516, Tw, Tv);
        io[WS(os, 2)] = SIMD_FNMADD(KP951056516, Tw, Tv);
        io[WS(os, 3)] = SIMD_FMADD(KP951056516, Tu, Tr);
        io[0]         = SIMD_FNMADD(KP951056516, Tu, Tr);
    }
}

template <>
struct c2cb_traits<5, 2>
{
    static constexpr long_t flops           = 44;
    static constexpr long_t operations      = 28;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 36;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 5 -skip-k 2 -name c2cb
 * -standalone */

/*
 * This function contains 28 FP additions, 16 FP multiplications,
 * (or, 12 additions, 0 multiplications, 16 fused multiply/add),
 * 36 stack variables, 4 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 2>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP559016994, +0.559016994374947424102293417182819058860154590);
    DK(KP250000000, +0.250000000000000000000000000000000000000000000);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T1, Tl, T2, T3, T5, T6, Tc, Td, Tf, Tg, T4, Tt, T7, Ts, Tm;
        SIMD_FLOAT Te, Tn, Th, Tu, Ta, T8, Ti, Tq, To, Tj, T9, Tp, Tv, Tk, Tb;
        SIMD_FLOAT Tr, Tw;
        T1            = ri[0];
        Tl            = ii[0];
        T2            = ri[WS(is, 1)];
        T3            = ri[WS(is, 4)];
        T5            = ri[WS(is, 2)];
        T6            = ri[WS(is, 3)];
        Tc            = ii[WS(is, 2)];
        Td            = ii[WS(is, 3)];
        Tf            = ii[WS(is, 4)];
        Tg            = ii[WS(is, 1)];
        T4            = T2 + T3;
        Tt            = T2 - T3;
        T7            = T5 + T6;
        Ts            = T5 - T6;
        Tm            = Tc + Td;
        Te            = Tc - Td;
        Tn            = Tf + Tg;
        Th            = Tf - Tg;
        Tu            = SIMD_FNMADD(KP618033988, Tt, Ts);
        Ta            = T4 - T7;
        T8            = T4 + T7;
        Ti            = SIMD_FMADD(KP618033988, Th, Te);
        Tq            = Tn - Tm;
        To            = Tm + Tn;
        Tj            = SIMD_FNMADD(KP951056516, Ta, Te);
        T9            = SIMD_FNMADD(KP250000000, T8, T1);
        Tp            = SIMD_FNMADD(KP250000000, To, Tl);
        Tv            = SIMD_FMADD(KP951056516, Tq, Ts);
        Tk            = SIMD_FNMADD(KP618033988, Tj, Th);
        Tb            = SIMD_FNMADD(KP559016994, Ta, T9);
        Tr            = SIMD_FNMADD(KP559016994, Tq, Tp);
        Tw            = SIMD_FMADD(KP618033988, Tv, Tt);
        ro[WS(os, 2)] = SIMD_FMADD(KP951056516, Tk, T9);
        ro[WS(os, 1)] = SIMD_FMADD(KP951056516, Ti, Tb);
        ro[0]         = SIMD_FNMADD(KP951056516, Ti, Tb);
        io[WS(os, 1)] = SIMD_FNMADD(KP951056516, Tu, Tr);
        io[0]         = SIMD_FMADD(KP951056516, Tu, Tr);
        io[WS(os, 2)] = SIMD_FMADD(KP951056516, Tw, Tp);
    }
}

template <>
struct c2cb_traits<5, 3>
{
    static constexpr long_t flops           = 40;
    static constexpr long_t operations      = 26;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 36;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 5 -skip-k 3 -name c2cb
 * -standalone */

/*
 * This function contains 26 FP additions, 14 FP multiplications,
 * (or, 12 additions, 0 multiplications, 14 fused multiply/add),
 * 36 stack variables, 4 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 3>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    DK(KP587785252, +0.587785252292473129168705954639072768597652438);
    DK(KP250000000, +0.250000000000000000000000000000000000000000000);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    {
        SIMD_FLOAT T1, Tl, T2, T3, T5, T6, Ta, Tb, Td, Te, T4, Tt, T7, Tq, Tm;
        SIMD_FLOAT Tc, Tn, Tf, T8, Tg, Tr, To, Th, Tj, T9, Tp, Tv, Ts, Ti, Tk;
        SIMD_FLOAT Tu, Tw;
        T1            = ri[0];
        Tl            = ii[0];
        T2            = ri[WS(is, 1)];
        T3            = ri[WS(is, 4)];
        T5            = ri[WS(is, 2)];
        T6            = ri[WS(is, 3)];
        Ta            = ii[WS(is, 2)];
        Tb            = ii[WS(is, 3)];
        Td            = ii[WS(is, 4)];
        Te            = ii[WS(is, 1)];
        T4            = T2 + T3;
        Tt            = T2 - T3;
        T7            = T5 + T6;
        Tq            = T5 - T6;
        Tm            = Ta + Tb;
        Tc            = Ta - Tb;
        Tn            = Td + Te;
        Tf            = Td - Te;
        T8            = T4 + T7;
        Tg            = T7 - T4;
        Tr            = Tn - Tm;
        To            = Tm + Tn;
        Th            = SIMD_FMADD(KP951056516, Tg, Tf);
        Tj            = SIMD_FMADD(KP951056516, Tg, Tc);
        T9            = SIMD_FNMADD(KP250000000, T8, T1);
        Tp            = SIMD_FNMADD(KP250000000, To, Tl);
        Tv            = SIMD_FMADD(KP951056516, Tr, Tq);
        Ts            = SIMD_FMADD(KP587785252, Tr, Tq);
        Ti            = SIMD_FMADD(KP618033988, Th, Tc);
        Tk            = SIMD_FNMADD(KP618033988, Tj, Tf);
        Tu            = SIMD_FNMADD(KP618033988, Tt, Ts);
        Tw            = SIMD_FMADD(KP618033988, Tv, Tt);
        ro[0]         = SIMD_FMADD(KP951056516, Ti, T9);
        ro[WS(os, 1)] = SIMD_FMADD(KP951056516, Tk, T9);
        io[0]         = SIMD_FNMADD(KP951056516, Tu, Tp);
        io[WS(os, 1)] = SIMD_FMADD(KP951056516, Tw, Tp);
    }
}

template <>
struct c2cb_traits<5, 4>
{
    static constexpr long_t flops           = 26;
    static constexpr long_t operations      = 16;
    static constexpr long_t memory_accesses = 12;
    static constexpr long_t stack_vars      = 26;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 5 -skip-k 4 -name c2cb
 * -standalone */

/*
 * This function contains 16 FP additions, 10 FP multiplications,
 * (or, 6 additions, 0 multiplications, 10 fused multiply/add),
 * 26 stack variables, 4 constants, and 12 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 4>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP726542528, +0.726542528005360885895466757480618749616092393);
    DK(KP525731112, +0.525731112119133606025669084847876607285497932);
    DK(KP850650808, +0.850650808352039932181540497063011072240401404);
    {
        SIMD_FLOAT T1, Tg, T2, T3, T4, T6, T7, T8, Ta, Tb, Tj, T5, Ti, T9, Th;
        SIMD_FLOAT Tc, Tk, Td, Tl, Te, Tm, Tf;
        T1    = ri[0];
        Tg    = ii[0];
        T2    = ii[WS(is, 4)];
        T3    = ii[WS(is, 1)];
        T4    = ri[WS(is, 2)];
        T6    = ri[WS(is, 3)];
        T7    = ii[WS(is, 3)];
        T8    = ii[WS(is, 2)];
        Ta    = ri[WS(is, 1)];
        Tb    = ri[WS(is, 4)];
        Tj    = T3 + T2;
        T5    = T2 - (SIMD_FMADD(KP850650808, T4, T3));
        Ti    = T4 - T6;
        T9    = T7 - T8;
        Th    = Ta - (SIMD_FMADD(KP850650808, T7, Tb));
        Tc    = Ta + Tb;
        Tk    = SIMD_FMADD(KP525731112, Tj, Ti);
        Td    = SIMD_FMADD(KP525731112, Tc, T9);
        Tl    = SIMD_FNMADD(KP726542528, Tk, T8);
        Te    = SIMD_FNMADD(KP726542528, Td, T6);
        Tm    = SIMD_FNMADD(KP850650808, Tl, Th);
        Tf    = SIMD_FNMADD(KP850650808, Te, T5);
        io[0] = SIMD_FMADD(KP951056516, Tm, Tg);
        ro[0] = SIMD_FMADD(KP951056516, Tf, T1);
    }
}
