//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct r2cb_traits<5, 0>
{
    static constexpr long_t flops           = 22;
    static constexpr long_t operations      = 12;
    static constexpr long_t memory_accesses = 10;
    static constexpr long_t stack_vars      = 17;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 5 -skip-k 0 -name r2cb
 * -standalone */

/*
 * This function contains 12 FP additions, 10 FP multiplications,
 * (or, 2 additions, 0 multiplications, 10 fused multiply/add),
 * 17 stack variables, 5 constants, and 10 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 0>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T8, T9, T1, T2, T3, Tc, Ta, T6, T4, T5, T7, Tb;
        T8            = Ci[WS(cs, 1)];
        T9            = Ci[WS(cs, 2)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 1)];
        T3            = Cr[WS(cs, 2)];
        Tc            = SIMD_FMSUB(KP618033988, T8, T9);
        Ta            = SIMD_FMADD(KP618033988, T9, T8);
        T6            = T2 - T3;
        T4            = T2 + T3;
        R0[0]         = SIMD_FMADD(KP2_000000000, T4, T1);
        T5            = SIMD_FNMADD(KP500000000, T4, T1);
        T7            = SIMD_FMADD(KP1_118033988, T6, T5);
        Tb            = SIMD_FNMADD(KP1_118033988, T6, T5);
        R0[WS(rs, 4)] = SIMD_FMADD(KP1_902113032, Ta, T7);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP1_902113032, Ta, T7);
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_902113032, Tc, Tb);
        R0[WS(rs, 2)] = SIMD_FNMADD(KP1_902113032, Tc, Tb);
    }
}

template <>
struct r2cb_traits<5, 1>
{
    static constexpr long_t flops           = 20;
    static constexpr long_t operations      = 11;
    static constexpr long_t memory_accesses = 9;
    static constexpr long_t stack_vars      = 16;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 5 -skip-k 1 -name r2cb
 * -standalone */

/*
 * This function contains 11 FP additions, 9 FP multiplications,
 * (or, 2 additions, 0 multiplications, 9 fused multiply/add),
 * 16 stack variables, 4 constants, and 9 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 1>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T8, T9, T1, T2, T3, Tc, Ta, T6, T4, T5, T7, Tb;
        T8            = Ci[WS(cs, 1)];
        T9            = Ci[WS(cs, 2)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 1)];
        T3            = Cr[WS(cs, 2)];
        Tc            = SIMD_FMSUB(KP618033988, T8, T9);
        Ta            = SIMD_FMADD(KP618033988, T9, T8);
        T6            = T2 - T3;
        T4            = T2 + T3;
        T5            = SIMD_FNMADD(KP500000000, T4, T1);
        T7            = SIMD_FMADD(KP1_118033988, T6, T5);
        Tb            = SIMD_FNMADD(KP1_118033988, T6, T5);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, Tc, Tb);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP1_902113032, Tc, Tb);
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_902113032, Ta, T7);
        R0[0]         = SIMD_FNMADD(KP1_902113032, Ta, T7);
    }
}

template <>
struct r2cb_traits<5, 2>
{
    static constexpr long_t flops           = 18;
    static constexpr long_t operations      = 10;
    static constexpr long_t memory_accesses = 8;
    static constexpr long_t stack_vars      = 17;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 5 -skip-k 2 -name r2cb
 * -standalone */

/*
 * This function contains 10 FP additions, 8 FP multiplications,
 * (or, 2 additions, 0 multiplications, 8 fused multiply/add),
 * 17 stack variables, 5 constants, and 8 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 2>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T1, T7, T6, T2, T3, Tc, T4, T8, T9, T5, Ta, Tb;
        T1            = Cr[0];
        T7            = Ci[WS(cs, 2)];
        T6            = Ci[WS(cs, 1)];
        T2            = Cr[WS(cs, 1)];
        T3            = Cr[WS(cs, 2)];
        Tc            = SIMD_FMSUB(KP618033988, T6, T7);
        T4            = T2 + T3;
        T8            = T2 - T3;
        T9            = SIMD_FMADD(KP951056516, T8, T7);
        T5            = SIMD_FNMADD(KP500000000, T4, T1);
        Ta            = SIMD_FMADD(KP618033988, T9, T6);
        Tb            = SIMD_FNMADD(KP1_118033988, T8, T5);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, Ta, T5);
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_902113032, Tc, Tb);
        R0[0]         = SIMD_FNMADD(KP1_902113032, Tc, Tb);
    }
}

template <>
struct r2cb_traits<5, 3>
{
    static constexpr long_t flops           = 16;
    static constexpr long_t operations      = 9;
    static constexpr long_t memory_accesses = 7;
    static constexpr long_t stack_vars      = 17;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 5 -skip-k 3 -name r2cb
 * -standalone */

/*
 * This function contains 9 FP additions, 7 FP multiplications,
 * (or, 2 additions, 0 multiplications, 7 fused multiply/add),
 * 17 stack variables, 5 constants, and 7 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 3>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    DK(KP587785252, +0.587785252292473129168705954639072768597652438);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T9, T6, T2, T3, T4, T7, T5, Tb, T8, Ta, Tc;
        T1            = Cr[0];
        T9            = Ci[WS(cs, 1)];
        T6            = Ci[WS(cs, 2)];
        T2            = Cr[WS(cs, 1)];
        T3            = Cr[WS(cs, 2)];
        T4            = T2 + T3;
        T7            = T2 - T3;
        T5            = SIMD_FNMADD(KP500000000, T4, T1);
        Tb            = SIMD_FMADD(KP951056516, T7, T6);
        T8            = SIMD_FMADD(KP587785252, T7, T6);
        Ta            = SIMD_FNMADD(KP618033988, T9, T8);
        Tc            = SIMD_FMADD(KP618033988, Tb, T9);
        R0[0]         = SIMD_FNMADD(KP1_902113032, Ta, T5);
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_902113032, Tc, T5);
    }
}

template <>
struct r2cb_traits<5, 4>
{
    static constexpr long_t flops           = 8;
    static constexpr long_t operations      = 4;
    static constexpr long_t memory_accesses = 6;
    static constexpr long_t stack_vars      = 12;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 5 -skip-k 4 -name r2cb
 * -standalone */

/*
 * This function contains 4 FP additions, 4 FP multiplications,
 * (or, 0 additions, 0 multiplications, 4 fused multiply/add),
 * 12 stack variables, 4 constants, and 6 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 5 && SkippedOutputs == 4>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP850650808, +0.850650808352039932181540497063011072240401404);
    DK(KP726542528, +0.726542528005360885895466757480618749616092393);
    DK(KP525731112, +0.525731112119133606025669084847876607285497932);
    {
        SIMD_FLOAT T1, T2, T3, T4, T5, T6, T7, T8;
        T1    = Cr[0];
        T2    = Ci[WS(cs, 1)];
        T3    = Cr[WS(cs, 2)];
        T4    = Ci[WS(cs, 2)];
        T5    = Cr[WS(cs, 1)];
        T6    = SIMD_FMADD(KP525731112, T5, T4);
        T7    = SIMD_FNMADD(KP726542528, T6, T3);
        T8    = SIMD_FNMADD(KP850650808, T7, T2);
        R0[0] = SIMD_FMADD(KP1_902113032, T8, T1);
    }
}
