//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct r2cb_traits<12, 0>
{
    static constexpr long_t flops           = 54;
    static constexpr long_t operations      = 38;
    static constexpr long_t memory_accesses = 24;
    static constexpr long_t stack_vars      = 40;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 0 -name
 * r2cb -standalone */

/*
 * This function contains 38 FP additions, 16 FP multiplications,
 * (or, 22 additions, 0 multiplications, 16 fused multiply/add),
 * 40 stack variables, 2 constants, and 24 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 0>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T8, T9, Ta, Tu, Tl, Tm, Te, T1, T2, Th, T4, T5, Tb, Tz, Tv;
        SIMD_FLOAT Tn, Td, T3, Tg, T6, Tk, Tc, Ty, Tw, Tp, Tf, T7, Tt, Tq, Ti;
        SIMD_FLOAT To, Ts, TC, TA, Tj, TB, Tx, Tr;
        T8             = Cr[WS(cs, 3)];
        T9             = Cr[WS(cs, 5)];
        Ta             = Cr[WS(cs, 1)];
        Tu             = Ci[WS(cs, 3)];
        Tl             = Ci[WS(cs, 5)];
        Tm             = Ci[WS(cs, 1)];
        Te             = Ci[WS(cs, 4)];
        T1             = Cr[0];
        T2             = Cr[WS(cs, 4)];
        Th             = Ci[WS(cs, 2)];
        T4             = Cr[WS(cs, 6)];
        T5             = Cr[WS(cs, 2)];
        Tb             = T9 + Ta;
        Tz             = T9 - Ta;
        Tv             = Tl + Tm;
        Tn             = Tl - Tm;
        Td             = T1 - T2;
        T3             = SIMD_FMADD(KP2_000000000, T2, T1);
        Tg             = T4 - T5;
        T6             = SIMD_FMADD(KP2_000000000, T5, T4);
        Tk             = SIMD_FNMADD(KP2_000000000, T8, Tb);
        Tc             = T8 + Tb;
        Ty             = SIMD_FMADD(KP2_000000000, Tu, Tv);
        Tw             = Tu - Tv;
        Tp             = SIMD_FNMADD(KP1_732050807, Te, Td);
        Tf             = SIMD_FMADD(KP1_732050807, Te, Td);
        T7             = T3 + T6;
        Tt             = T3 - T6;
        Tq             = SIMD_FMADD(KP1_732050807, Th, Tg);
        Ti             = SIMD_FNMADD(KP1_732050807, Th, Tg);
        To             = SIMD_FMADD(KP1_732050807, Tn, Tk);
        Ts             = SIMD_FNMADD(KP1_732050807, Tn, Tk);
        TC             = SIMD_FNMADD(KP1_732050807, Tz, Ty);
        TA             = SIMD_FMADD(KP1_732050807, Tz, Ty);
        R0[WS(rs, 3)]  = SIMD_FMADD(KP2_000000000, Tw, Tt);
        R0[WS(rs, 9)]  = SIMD_FNMADD(KP2_000000000, Tw, Tt);
        R0[0]          = SIMD_FMADD(KP2_000000000, Tc, T7);
        R0[WS(rs, 6)]  = SIMD_FNMADD(KP2_000000000, Tc, T7);
        Tj             = Tf + Ti;
        TB             = Tf - Ti;
        Tx             = Tp - Tq;
        Tr             = Tp + Tq;
        R0[WS(rs, 11)] = TB + TC;
        R0[WS(rs, 5)]  = TB - TC;
        R0[WS(rs, 8)]  = Tj - To;
        R0[WS(rs, 2)]  = Tj + To;
        R0[WS(rs, 4)]  = Tr - Ts;
        R0[WS(rs, 10)] = Tr + Ts;
        R0[WS(rs, 7)]  = Tx + TA;
        R0[WS(rs, 1)]  = Tx - TA;
    }
}

template <>
struct r2cb_traits<12, 1>
{
    static constexpr long_t flops           = 52;
    static constexpr long_t operations      = 37;
    static constexpr long_t memory_accesses = 23;
    static constexpr long_t stack_vars      = 38;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 1 -name
 * r2cb -standalone */

/*
 * This function contains 37 FP additions, 15 FP multiplications,
 * (or, 22 additions, 0 multiplications, 15 fused multiply/add),
 * 38 stack variables, 2 constants, and 23 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 1>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T8, T9, Ta, Tu, Tl, Tm, Te, T1, T2, Th, T4, T5, Tb, Tx, Tt;
        SIMD_FLOAT Tn, Td, T3, Tg, T6, Tk, Tc, Tw, Tf, Tp, T7, Ti, Tq, To, Ts;
        SIMD_FLOAT Ty, TA, Tj, Tv, Tr, Tz;
        T8             = Ci[WS(cs, 3)];
        T9             = Ci[WS(cs, 5)];
        Ta             = Ci[WS(cs, 1)];
        Tu             = Cr[WS(cs, 3)];
        Tl             = Cr[WS(cs, 5)];
        Tm             = Cr[WS(cs, 1)];
        Te             = Ci[WS(cs, 4)];
        T1             = Cr[0];
        T2             = Cr[WS(cs, 4)];
        Th             = Ci[WS(cs, 2)];
        T4             = Cr[WS(cs, 6)];
        T5             = Cr[WS(cs, 2)];
        Tb             = T9 + Ta;
        Tx             = T9 - Ta;
        Tt             = Tl + Tm;
        Tn             = Tl - Tm;
        Td             = T1 - T2;
        T3             = SIMD_FMADD(KP2_000000000, T2, T1);
        Tg             = T4 - T5;
        T6             = SIMD_FMADD(KP2_000000000, T5, T4);
        Tk             = SIMD_FMADD(KP2_000000000, T8, Tb);
        Tc             = T8 - Tb;
        Tw             = SIMD_FNMADD(KP2_000000000, Tu, Tt);
        Tf             = SIMD_FMADD(KP1_732050807, Te, Td);
        Tp             = SIMD_FNMADD(KP1_732050807, Te, Td);
        T7             = T3 - T6;
        R0[WS(rs, 5)]  = T3 + SIMD_FNMADD(KP2_000000000, Tt + Tu, T6);
        Ti             = SIMD_FNMADD(KP1_732050807, Th, Tg);
        Tq             = SIMD_FMADD(KP1_732050807, Th, Tg);
        To             = SIMD_FNMADD(KP1_732050807, Tn, Tk);
        Ts             = SIMD_FMADD(KP1_732050807, Tn, Tk);
        Ty             = SIMD_FMADD(KP1_732050807, Tx, Tw);
        TA             = SIMD_FNMADD(KP1_732050807, Tx, Tw);
        R0[WS(rs, 2)]  = SIMD_FMADD(KP2_000000000, Tc, T7);
        R0[WS(rs, 8)]  = SIMD_FNMADD(KP2_000000000, Tc, T7);
        Tj             = Tf - Ti;
        Tv             = Tf + Ti;
        Tr             = Tp - Tq;
        Tz             = Tp + Tq;
        R0[WS(rs, 10)] = Tj + To;
        R0[WS(rs, 4)]  = Tj - To;
        R0[WS(rs, 7)]  = Tv - Ty;
        R0[WS(rs, 1)]  = Tv + Ty;
        R0[WS(rs, 6)]  = Tr + Ts;
        R0[0]          = Tr - Ts;
        R0[WS(rs, 3)]  = Tz - TA;
        R0[WS(rs, 9)]  = Tz + TA;
    }
}

template <>
struct r2cb_traits<12, 2>
{
    static constexpr long_t flops           = 51;
    static constexpr long_t operations      = 36;
    static constexpr long_t memory_accesses = 22;
    static constexpr long_t stack_vars      = 36;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 2 -name
 * r2cb -standalone */

/*
 * This function contains 36 FP additions, 15 FP multiplications,
 * (or, 21 additions, 0 multiplications, 15 fused multiply/add),
 * 36 stack variables, 2 constants, and 22 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 2>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T7, T8, T9, Ts, Tj, Tk, Tc, T1, T2, Tf, T4, T5, Ta, Tx, Tt;
        SIMD_FLOAT Tl, Tb, T3, Te, T6, Ti, Tu, Tw, Td, Tn, Tr, Tg, To, Tq, Tm;
        SIMD_FLOAT Ty, Th, Tv, Tp;
        T7            = Cr[WS(cs, 3)];
        T8            = Cr[WS(cs, 5)];
        T9            = Cr[WS(cs, 1)];
        Ts            = Ci[WS(cs, 3)];
        Tj            = Ci[WS(cs, 5)];
        Tk            = Ci[WS(cs, 1)];
        Tc            = Ci[WS(cs, 4)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        Tf            = Ci[WS(cs, 2)];
        T4            = Cr[WS(cs, 6)];
        T5            = Cr[WS(cs, 2)];
        Ta            = T8 + T9;
        Tx            = T8 - T9;
        Tt            = Tj + Tk;
        Tl            = Tj - Tk;
        Tb            = T1 - T2;
        T3            = SIMD_FMADD(KP2_000000000, T2, T1);
        Te            = T4 - T5;
        T6            = SIMD_FMADD(KP2_000000000, T5, T4);
        Ti            = SIMD_FNMADD(KP2_000000000, T7, Ta);
        Tu            = Ts - Tt;
        Tw            = SIMD_FMADD(KP2_000000000, Ts, Tt);
        Td            = SIMD_FMADD(KP1_732050807, Tc, Tb);
        Tn            = SIMD_FNMADD(KP1_732050807, Tc, Tb);
        Tr            = T3 - T6;
        R0[WS(rs, 4)] = T3 + SIMD_FNMADD(KP2_000000000, T7 + Ta, T6);
        Tg            = SIMD_FNMADD(KP1_732050807, Tf, Te);
        To            = SIMD_FMADD(KP1_732050807, Tf, Te);
        Tq            = SIMD_FNMADD(KP1_732050807, Tl, Ti);
        Tm            = SIMD_FMADD(KP1_732050807, Tl, Ti);
        Ty            = SIMD_FNMADD(KP1_732050807, Tx, Tw);
        R0[WS(rs, 1)] = SIMD_FMADD(KP2_000000000, Tu, Tr);
        R0[WS(rs, 7)] = SIMD_FNMADD(KP2_000000000, Tu, Tr);
        Th            = Td + Tg;
        Tv            = Td - Tg;
        Tp            = Tn + To;
        R0[WS(rs, 5)] = SIMD_FMADD(KP1_732050807, Tx, Tn) + Tw - To;
        R0[WS(rs, 9)] = Tv + Ty;
        R0[WS(rs, 3)] = Tv - Ty;
        R0[WS(rs, 6)] = Th - Tm;
        R0[0]         = Th + Tm;
        R0[WS(rs, 2)] = Tp - Tq;
        R0[WS(rs, 8)] = Tp + Tq;
    }
}

template <>
struct r2cb_traits<12, 3>
{
    static constexpr long_t flops           = 50;
    static constexpr long_t operations      = 35;
    static constexpr long_t memory_accesses = 21;
    static constexpr long_t stack_vars      = 34;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 3 -name
 * r2cb -standalone */

/*
 * This function contains 35 FP additions, 15 FP multiplications,
 * (or, 20 additions, 0 multiplications, 15 fused multiply/add),
 * 34 stack variables, 2 constants, and 21 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 3>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T8, T9, Ta, Tn, Tk, Tl, Te, T1, T2, Th, T4, T5, Tb, Tp, Tm;
        SIMD_FLOAT Tv, Td, T3, Tg, T6, Tu, Tc, To, Tf, Tr, T7, Ti, Ts, Tw, Tq;
        SIMD_FLOAT Tj, Tt;
        T8            = Ci[WS(cs, 3)];
        T9            = Ci[WS(cs, 5)];
        Ta            = Ci[WS(cs, 1)];
        Tn            = Cr[WS(cs, 3)];
        Tk            = Cr[WS(cs, 5)];
        Tl            = Cr[WS(cs, 1)];
        Te            = Ci[WS(cs, 4)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        Th            = Ci[WS(cs, 2)];
        T4            = Cr[WS(cs, 6)];
        T5            = Cr[WS(cs, 2)];
        Tb            = T9 + Ta;
        Tp            = T9 - Ta;
        Tm            = Tk + Tl;
        Tv            = Tk - Tl;
        Td            = T1 - T2;
        T3            = SIMD_FMADD(KP2_000000000, T2, T1);
        Tg            = T4 - T5;
        T6            = SIMD_FMADD(KP2_000000000, T5, T4);
        Tu            = SIMD_FMADD(KP2_000000000, T8, Tb);
        Tc            = T8 - Tb;
        To            = SIMD_FNMADD(KP2_000000000, Tn, Tm);
        Tf            = SIMD_FNMADD(KP1_732050807, Te, Td);
        Tr            = SIMD_FMADD(KP1_732050807, Te, Td);
        T7            = T3 - T6;
        R0[WS(rs, 3)] = T3 + SIMD_FNMADD(KP2_000000000, Tn + Tm, T6);
        Ti            = SIMD_FMADD(KP1_732050807, Th, Tg);
        Ts            = SIMD_FNMADD(KP1_732050807, Th, Tg);
        Tw            = SIMD_FNMADD(KP1_732050807, Tv, Tu);
        Tq            = SIMD_FNMADD(KP1_732050807, Tp, To);
        R0[0]         = SIMD_FMADD(KP2_000000000, Tc, T7);
        R0[WS(rs, 6)] = SIMD_FNMADD(KP2_000000000, Tc, T7);
        Tj            = Tf + Ti;
        R0[WS(rs, 4)] = Tu + SIMD_FMADD(KP1_732050807, Tv, Tf) - Ti;
        Tt            = Tr - Ts;
        R0[WS(rs, 5)] = Tr + Ts + SIMD_FNMSUB(KP1_732050807, Tp, To);
        R0[WS(rs, 1)] = Tj - Tq;
        R0[WS(rs, 7)] = Tj + Tq;
        R0[WS(rs, 8)] = Tt + Tw;
        R0[WS(rs, 2)] = Tt - Tw;
    }
}

template <>
struct r2cb_traits<12, 4>
{
    static constexpr long_t flops           = 49;
    static constexpr long_t operations      = 34;
    static constexpr long_t memory_accesses = 20;
    static constexpr long_t stack_vars      = 32;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 4 -name
 * r2cb -standalone */

/*
 * This function contains 34 FP additions, 15 FP multiplications,
 * (or, 19 additions, 0 multiplications, 15 fused multiply/add),
 * 32 stack variables, 2 constants, and 20 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 4>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T7, T8, T9, Tq, Th, Ti, Tc, T1, T2, Tf, T4, T5, Ta, Tt, Tp;
        SIMD_FLOAT Tj, Tb, T3, Te, T6, Tk, Ts, Tl, Td, Tm, Tg, To, Tu, Tr, Tn;
        T7            = Cr[WS(cs, 3)];
        T8            = Cr[WS(cs, 5)];
        T9            = Cr[WS(cs, 1)];
        Tq            = Ci[WS(cs, 3)];
        Th            = Ci[WS(cs, 5)];
        Ti            = Ci[WS(cs, 1)];
        Tc            = Ci[WS(cs, 4)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        Tf            = Ci[WS(cs, 2)];
        T4            = Cr[WS(cs, 6)];
        T5            = Cr[WS(cs, 2)];
        Ta            = T8 + T9;
        Tt            = T8 - T9;
        Tp            = Th + Ti;
        Tj            = Th - Ti;
        Tb            = T1 - T2;
        T3            = SIMD_FMADD(KP2_000000000, T2, T1);
        Te            = T4 - T5;
        T6            = SIMD_FMADD(KP2_000000000, T5, T4);
        Tk            = SIMD_FNMADD(KP2_000000000, T7, Ta);
        Ts            = SIMD_FMADD(KP2_000000000, Tq, Tp);
        Tl            = SIMD_FNMADD(KP1_732050807, Tc, Tb);
        Td            = SIMD_FMADD(KP1_732050807, Tc, Tb);
        R0[WS(rs, 5)] = SIMD_FMADD(KP2_000000000, Tp, T3) -
                        (SIMD_FMADD(KP2_000000000, Tq, T6));
        R0[WS(rs, 2)] = T3 + SIMD_FNMADD(KP2_000000000, T7 + Ta, T6);
        Tm            = SIMD_FMADD(KP1_732050807, Tf, Te);
        Tg            = SIMD_FNMADD(KP1_732050807, Tf, Te);
        To            = SIMD_FNMADD(KP1_732050807, Tj, Tk);
        Tu            = SIMD_FNMADD(KP1_732050807, Tt, Ts);
        Tr            = Td - Tg;
        R0[WS(rs, 4)] = Td + SIMD_FNMADD(KP1_732050807, Tj, Tg) - Tk;
        Tn            = Tl + Tm;
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_732050807, Tt, Tl) + Ts - Tm;
        R0[WS(rs, 7)] = Tr + Tu;
        R0[WS(rs, 1)] = Tr - Tu;
        R0[0]         = Tn - To;
        R0[WS(rs, 6)] = Tn + To;
    }
}

template <>
struct r2cb_traits<12, 5>
{
    static constexpr long_t flops           = 47;
    static constexpr long_t operations      = 34;
    static constexpr long_t memory_accesses = 19;
    static constexpr long_t stack_vars      = 30;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 5 -name
 * r2cb -standalone */

/*
 * This function contains 33 FP additions, 14 FP multiplications,
 * (or, 20 additions, 1 multiplications, 13 fused multiply/add),
 * 30 stack variables, 2 constants, and 19 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 5>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    {
        SIMD_FLOAT Tq, Ta, T4, T5, Tj, Tk, Tc, T1, T2, Tf, T7, T8, T6, Tr, Tl;
        SIMD_FLOAT Tp, Tb, T3, Te, T9, Ti, Ts, Td, Tn, Tg, To, Tm, Th;
        Tq            = Cr[WS(cs, 3)];
        Ta            = Ci[WS(cs, 3)];
        T4            = Ci[WS(cs, 5)];
        T5            = Ci[WS(cs, 1)];
        Tj            = Cr[WS(cs, 5)];
        Tk            = Cr[WS(cs, 1)];
        Tc            = Ci[WS(cs, 4)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        Tf            = Ci[WS(cs, 2)];
        T7            = Cr[WS(cs, 6)];
        T8            = Cr[WS(cs, 2)];
        T6            = T4 + T5;
        Tr            = KP1_732050807 * (T5 - T4);
        Tl            = Tj - Tk;
        Tp            = Tj + Tk;
        Tb            = T1 - T2;
        T3            = SIMD_FMADD(KP2_000000000, T2, T1);
        Te            = T7 - T8;
        T9            = SIMD_FMADD(KP2_000000000, T8, T7);
        Ti            = SIMD_FMADD(KP2_000000000, Ta, T6);
        Ts            = SIMD_FNMADD(KP2_000000000, Tq, Tp);
        Td            = SIMD_FMADD(KP1_732050807, Tc, Tb);
        Tn            = SIMD_FNMADD(KP1_732050807, Tc, Tb);
        R0[WS(rs, 1)] = T3 + SIMD_FNMADD(KP2_000000000, Tp + Tq, T9);
        R0[WS(rs, 4)] = SIMD_FMADD(KP2_000000000, T6, T3) -
                        (SIMD_FMADD(KP2_000000000, Ta, T9));
        Tg            = SIMD_FNMADD(KP1_732050807, Tf, Te);
        To            = SIMD_FMADD(KP1_732050807, Tf, Te);
        Tm            = SIMD_FNMADD(KP1_732050807, Tl, Ti);
        R0[WS(rs, 5)] = Tn + To + Tr + Ts;
        R0[WS(rs, 2)] = Tn + SIMD_FMADD(KP1_732050807, Tl, Ti) - To;
        R0[WS(rs, 3)] = Td + Tg + Tr - Ts;
        Th            = Td - Tg;
        R0[WS(rs, 6)] = Th + Tm;
        R0[0]         = Th - Tm;
    }
}

template <>
struct r2cb_traits<12, 6>
{
    static constexpr long_t flops           = 46;
    static constexpr long_t operations      = 33;
    static constexpr long_t memory_accesses = 18;
    static constexpr long_t stack_vars      = 28;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 6 -name
 * r2cb -standalone */

/*
 * This function contains 32 FP additions, 14 FP multiplications,
 * (or, 19 additions, 1 multiplications, 13 fused multiply/add),
 * 28 stack variables, 2 constants, and 18 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 6>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T7, Ti, Td, Tl, T4, T5, Tf, Tg, T8, T9, T1, T2, T6, Tk, Th;
        SIMD_FLOAT Tp, Ta, Tb, T3, Tc, To, Tm, Tj, Tq, Te, Tn;
        T7            = Cr[WS(cs, 3)];
        Ti            = Ci[WS(cs, 3)];
        Td            = Ci[WS(cs, 4)];
        Tl            = Ci[WS(cs, 2)];
        T4            = Cr[WS(cs, 6)];
        T5            = Cr[WS(cs, 2)];
        Tf            = Ci[WS(cs, 5)];
        Tg            = Ci[WS(cs, 1)];
        T8            = Cr[WS(cs, 5)];
        T9            = Cr[WS(cs, 1)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        T6            = SIMD_FMADD(KP2_000000000, T5, T4);
        Tk            = T4 - T5;
        Th            = Tf + Tg;
        Tp            = KP1_732050807 * (Tg - Tf);
        Ta            = T8 + T9;
        Tb            = T8 - T9;
        T3            = SIMD_FMADD(KP2_000000000, T2, T1);
        Tc            = T1 - T2;
        To            = SIMD_FNMADD(KP1_732050807, Tl, Tk);
        Tm            = SIMD_FMADD(KP1_732050807, Tl, Tk);
        Tj            = SIMD_FMADD(KP2_000000000, Ti, Th);
        Tq            = SIMD_FNMADD(KP2_000000000, T7, Ta);
        Te            = SIMD_FNMADD(KP1_732050807, Td, Tc);
        Tn            = SIMD_FMADD(KP1_732050807, Td, Tc);
        R0[WS(rs, 3)] = SIMD_FMADD(KP2_000000000, Th, T3) -
                        (SIMD_FMADD(KP2_000000000, Ti, T6));
        R0[0]         = T3 + SIMD_FNMADD(KP2_000000000, T7 + Ta, T6);
        R0[WS(rs, 2)] = Tn + To + Tp - Tq;
        R0[WS(rs, 5)] = Tn + Tj - (SIMD_FMADD(KP1_732050807, Tb, To));
        R0[WS(rs, 4)] = Tq + Te + Tm + Tp;
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_732050807, Tb, Te) + Tj - Tm;
    }
}

template <>
struct r2cb_traits<12, 7>
{
    static constexpr long_t flops           = 40;
    static constexpr long_t operations      = 30;
    static constexpr long_t memory_accesses = 17;
    static constexpr long_t stack_vars      = 25;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 7 -name
 * r2cb -standalone */

/*
 * This function contains 29 FP additions, 11 FP multiplications,
 * (or, 19 additions, 1 multiplications, 10 fused multiply/add),
 * 25 stack variables, 2 constants, and 17 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 7>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    {
        SIMD_FLOAT T8, Ta, Te, T1, T2, T6, T7, T3, T4, Tg, Tm, Th, T9, Td, T5;
        SIMD_FLOAT Tl, Tn, Ti, Tb, Tj, Tk, Tf, Tc;
        T8            = Ci[WS(cs, 3)];
        Ta            = Ci[WS(cs, 4)];
        Te            = Ci[WS(cs, 2)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        T6            = Cr[WS(cs, 2)];
        T7            = Cr[WS(cs, 6)];
        T3            = Ci[WS(cs, 5)];
        T4            = Ci[WS(cs, 1)];
        Tg            = Cr[WS(cs, 5)];
        Tm            = Cr[WS(cs, 3)];
        Th            = Cr[WS(cs, 1)];
        T9            = T1 - T2;
        Td            = T7 - T6;
        T5            = T3 + T4;
        Tl            = KP1_732050807 * (T4 - T3);
        Tn            = SIMD_FMSUB(KP2_000000000, Tm, Th) - Tg;
        Ti            = Tg - Th;
        Tb            = SIMD_FMADD(KP1_732050807, Ta, T9);
        Tj            = SIMD_FNMADD(KP1_732050807, Ta, T9);
        Tk            = SIMD_FMADD(KP1_732050807, Te, Td);
        Tf            = SIMD_FNMADD(KP1_732050807, Te, Td);
        Tc            = SIMD_FMADD(KP2_000000000, T8, T5);
        R0[WS(rs, 2)] = SIMD_FMADD(KP2_000000000, T2 + T5 - T6, T1) -
                        (SIMD_FMADD(KP2_000000000, T8, T7));
        R0[WS(rs, 1)] = Tb + Tf + Tl + Tn;
        R0[WS(rs, 3)] = Tj + Tk + Tl - Tn;
        R0[0]         = Tj + SIMD_FMADD(KP1_732050807, Ti, Tc) - Tk;
        R0[WS(rs, 4)] = Tb + Tc - (SIMD_FMADD(KP1_732050807, Ti, Tf));
    }
}

template <>
struct r2cb_traits<12, 8>
{
    static constexpr long_t flops           = 36;
    static constexpr long_t operations      = 26;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 23;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 8 -name
 * r2cb -standalone */

/*
 * This function contains 26 FP additions, 10 FP multiplications,
 * (or, 16 additions, 0 multiplications, 10 fused multiply/add),
 * 23 stack variables, 3 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 8>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T4, T9, T1, T2, Tj, T6, T7, Tf, Tg, Tb, Td, Tc, T3, T8, Th;
        SIMD_FLOAT Ti, Te, Tk, T5, Ta;
        T4            = Ci[WS(cs, 4)];
        T9            = Ci[WS(cs, 2)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        Tj            = Ci[WS(cs, 3)];
        T6            = Cr[WS(cs, 6)];
        T7            = Cr[WS(cs, 2)];
        Tf            = Ci[WS(cs, 1)];
        Tg            = Ci[WS(cs, 5)];
        Tb            = Cr[WS(cs, 3)];
        Td            = Cr[WS(cs, 5)];
        Tc            = Cr[WS(cs, 1)];
        T3            = T1 - T2;
        T8            = T6 - T7;
        Th            = Tf - Tg;
        Ti            = Tg + Tf;
        Te            = SIMD_FMSUB(KP2_000000000, Tb, Tc) - Td;
        Tk            = Tc - Td;
        T5            = SIMD_FMADD(KP1_732050807, T4, T3);
        Ta            = SIMD_FNMADD(KP1_732050807, T9, T8);
        R0[WS(rs, 1)] = SIMD_FMADD(KP2_000000000, T2 + Ti - T7, T1) -
                        (SIMD_FMADD(KP2_000000000, Tj, T6));
        R0[WS(rs, 2)] = T3 + SIMD_FMADD(KP1_732050807, T9 + Th, T8) -
                        (SIMD_FMADD(KP1_732050807, T4, Te));
        R0[WS(rs, 3)] =
            T5 +
            SIMD_FMADD(KP2_000000000, SIMD_FMADD(KP866025403, Tk, Tj), Ti) - Ta;
        R0[0] = T5 + Ta + SIMD_FMADD(KP1_732050807, Th, Te);
    }
}

template <>
struct r2cb_traits<12, 9>
{
    static constexpr long_t flops           = 28;
    static constexpr long_t operations      = 21;
    static constexpr long_t memory_accesses = 15;
    static constexpr long_t stack_vars      = 20;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 9 -name
 * r2cb -standalone */

/*
 * This function contains 21 FP additions, 7 FP multiplications,
 * (or, 14 additions, 0 multiplications, 7 fused multiply/add),
 * 20 stack variables, 3 constants, and 15 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 9>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    {
        SIMD_FLOAT T7, Td, Tb, Tc, T2, T3, T5, Tf, T8, T1, T9, T6, Th, Te, T4;
        SIMD_FLOAT Tg, Ta;
        T7    = Ci[WS(cs, 3)];
        Td    = Cr[WS(cs, 3)];
        Tb    = Cr[WS(cs, 5)];
        Tc    = Cr[WS(cs, 1)];
        T2    = Ci[WS(cs, 5)];
        T3    = Ci[WS(cs, 1)];
        T5    = Cr[WS(cs, 2)];
        Tf    = Ci[WS(cs, 4)];
        T8    = Cr[WS(cs, 6)];
        T1    = Cr[0];
        T9    = Ci[WS(cs, 2)];
        T6    = Cr[WS(cs, 4)];
        Th    = Tc - Tb;
        Te    = T3 - T2;
        T4    = T2 + T3;
        Tg    = SIMD_FMADD(KP1_732050807, Tf, T5) - T8;
        Ta    = SIMD_FMADD(KP1_732050807, T9, T1) - T6;
        R0[0] = SIMD_FMADD(KP2_000000000, (T4 - (T5 - T6)) - T7, T1) - T8;
        R0[WS(rs, 1)] =
            Ta + Tb +
            SIMD_FMADD(KP2_000000000, SIMD_FMSUB(KP866025403, Te, Td), Tc) - Tg;
        R0[WS(rs, 2)] =
            T4 + Tg +
            SIMD_FMADD(KP2_000000000, SIMD_FMADD(KP866025403, Th, T7), Ta);
    }
}

template <>
struct r2cb_traits<12, 10>
{
    static constexpr long_t flops           = 22;
    static constexpr long_t operations      = 16;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 19;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 10 -name
 * r2cb -standalone */

/*
 * This function contains 16 FP additions, 6 FP multiplications,
 * (or, 10 additions, 0 multiplications, 6 fused multiply/add),
 * 19 stack variables, 3 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 10>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP1_732050807, +1.732050807568877293527446341505872366942805254);
    {
        SIMD_FLOAT Tb, Tf, T9, Ta, Tc, Td, T5, T7, T6, T1, T3, T2, Tg, Te, T8;
        SIMD_FLOAT T4;
        Tb = Cr[WS(cs, 3)];
        Tf = Ci[WS(cs, 3)];
        T9 = Cr[WS(cs, 5)];
        Ta = Cr[WS(cs, 1)];
        Tc = Ci[WS(cs, 1)];
        Td = Ci[WS(cs, 5)];
        T5 = Cr[0];
        T7 = Cr[WS(cs, 4)];
        T6 = Ci[WS(cs, 2)];
        T1 = Cr[WS(cs, 6)];
        T3 = Ci[WS(cs, 4)];
        T2 = Cr[WS(cs, 2)];
        Tg = Ta - T9;
        Te = Tc - Td;
        T8 = SIMD_FMADD(KP1_732050807, T6, T5) - T7;
        T4 = T1 + SIMD_FNMSUB(KP1_732050807, T3, T2);
        R0[WS(rs, 1)] =
            T8 + Td +
            SIMD_FMADD(KP2_000000000, SIMD_FMADD(KP866025403, Tg, Tf), Tc) - T4;
        R0[0] = T4 + T8 + T9 +
                SIMD_FMADD(KP2_000000000, SIMD_FMSUB(KP866025403, Te, Tb), Ta);
    }
}

template <>
struct r2cb_traits<12, 11>
{
    static constexpr long_t flops           = 12;
    static constexpr long_t operations      = 10;
    static constexpr long_t memory_accesses = 12;
    static constexpr long_t stack_vars      = 14;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 12 -skip-k 11 -name
 * r2cb -standalone */

/*
 * This function contains 10 FP additions, 2 FP multiplications,
 * (or, 8 additions, 0 multiplications, 2 fused multiply/add),
 * 14 stack variables, 2 constants, and 12 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 12 && SkippedOutputs == 11>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, Tb, Tc, T2, T3, T4, T5, T6, T9, T7, T8, Ta;
        T1    = Cr[0];
        Tb    = Cr[WS(cs, 4)];
        Tc    = Cr[WS(cs, 6)];
        T2    = Cr[WS(cs, 2)];
        T3    = Ci[WS(cs, 5)];
        T4    = Ci[WS(cs, 1)];
        T5    = Ci[WS(cs, 3)];
        T6    = Ci[WS(cs, 4)];
        T9    = Cr[WS(cs, 5)];
        T7    = Ci[WS(cs, 2)];
        T8    = Cr[WS(cs, 1)];
        Ta    = T6 + T7 + T8 - T9;
        R0[0] = T1 + T2 + T3 +
                SIMD_FMADD(KP2_000000000, SIMD_FMADD(KP866025403, Ta, T5), T4) -
                (Tb + Tc);
    }
}
