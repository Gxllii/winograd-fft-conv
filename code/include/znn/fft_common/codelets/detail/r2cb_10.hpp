//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct r2cb_traits<10, 0>
{
    static constexpr long_t flops           = 54;
    static constexpr long_t operations      = 34;
    static constexpr long_t memory_accesses = 20;
    static constexpr long_t stack_vars      = 39;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 0 -name
 * r2cb -standalone */

/*
 * This function contains 34 FP additions, 20 FP multiplications,
 * (or, 14 additions, 0 multiplications, 20 fused multiply/add),
 * 39 stack variables, 5 constants, and 20 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 0>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT T1, T2, Tl, Tm, Ti, Tj, T4, T5, T7, T8, T3, Tb, Tn, Tu, Tk;
        SIMD_FLOAT Tv, T6, Tc, T9, Td, Tw, Ty, To, Tq, Te, Tg, Ta, Ts, Tf, Tr;
        SIMD_FLOAT Th, Tp, Tt, Tx;
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        Tl            = Ci[WS(cs, 2)];
        Tm            = Ci[WS(cs, 3)];
        Ti            = Ci[WS(cs, 4)];
        Tj            = Ci[WS(cs, 1)];
        T4            = Cr[WS(cs, 2)];
        T5            = Cr[WS(cs, 3)];
        T7            = Cr[WS(cs, 4)];
        T8            = Cr[WS(cs, 1)];
        T3            = T1 - T2;
        Tb            = T1 + T2;
        Tn            = Tl - Tm;
        Tu            = Tl + Tm;
        Tk            = Ti - Tj;
        Tv            = Ti + Tj;
        T6            = T4 - T5;
        Tc            = T4 + T5;
        T9            = T7 - T8;
        Td            = T7 + T8;
        Tw            = SIMD_FMADD(KP618033988, Tv, Tu);
        Ty            = SIMD_FNMADD(KP618033988, Tu, Tv);
        To            = SIMD_FNMADD(KP618033988, Tn, Tk);
        Tq            = SIMD_FMADD(KP618033988, Tk, Tn);
        Te            = Tc + Td;
        Tg            = Tc - Td;
        Ta            = T6 + T9;
        Ts            = T6 - T9;
        Tf            = SIMD_FNMADD(KP500000000, Te, Tb);
        R0[0]         = SIMD_FMADD(KP2_000000000, Te, Tb);
        Tr            = SIMD_FNMADD(KP500000000, Ta, T3);
        R0[WS(rs, 5)] = SIMD_FMADD(KP2_000000000, Ta, T3);
        Th            = SIMD_FNMADD(KP1_118033988, Tg, Tf);
        Tp            = SIMD_FMADD(KP1_118033988, Tg, Tf);
        Tt            = SIMD_FMADD(KP1_118033988, Ts, Tr);
        Tx            = SIMD_FNMADD(KP1_118033988, Ts, Tr);
        R0[WS(rs, 6)] = SIMD_FNMADD(KP1_902113032, Tq, Tp);
        R0[WS(rs, 4)] = SIMD_FMADD(KP1_902113032, Tq, Tp);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, To, Th);
        R0[WS(rs, 8)] = SIMD_FNMADD(KP1_902113032, To, Th);
        R0[WS(rs, 3)] = SIMD_FNMADD(KP1_902113032, Ty, Tx);
        R0[WS(rs, 7)] = SIMD_FMADD(KP1_902113032, Ty, Tx);
        R0[WS(rs, 9)] = SIMD_FMADD(KP1_902113032, Tw, Tt);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP1_902113032, Tw, Tt);
    }
}

template <>
struct r2cb_traits<10, 1>
{
    static constexpr long_t flops           = 52;
    static constexpr long_t operations      = 33;
    static constexpr long_t memory_accesses = 19;
    static constexpr long_t stack_vars      = 37;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 1 -name
 * r2cb -standalone */

/*
 * This function contains 33 FP additions, 19 FP multiplications,
 * (or, 14 additions, 0 multiplications, 19 fused multiply/add),
 * 37 stack variables, 5 constants, and 19 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 1>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT Tg, Th, Tj, Tk, T1, T2, T4, T5, T7, T8, Ti, Tt, Tl, Ts, T3;
        SIMD_FLOAT Tb, T6, Tc, T9, Tw, Tu, Tm, To, Td, Te, Ta, Tq, Tf, Tn, Tp;
        SIMD_FLOAT Tv, Tr;
        Tg            = Ci[WS(cs, 4)];
        Th            = Ci[WS(cs, 1)];
        Tj            = Ci[WS(cs, 2)];
        Tk            = Ci[WS(cs, 3)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        T4            = Cr[WS(cs, 2)];
        T5            = Cr[WS(cs, 3)];
        T7            = Cr[WS(cs, 4)];
        T8            = Cr[WS(cs, 1)];
        Ti            = Tg - Th;
        Tt            = Tg + Th;
        Tl            = Tj - Tk;
        Ts            = Tj + Tk;
        T3            = T1 - T2;
        Tb            = T4 + T5;
        T6            = T4 - T5;
        Tc            = T7 + T8;
        T9            = T7 - T8;
        Tw            = SIMD_FNMADD(KP618033988, Ts, Tt);
        Tu            = SIMD_FMADD(KP618033988, Tt, Ts);
        Tm            = SIMD_FNMADD(KP618033988, Tl, Ti);
        To            = SIMD_FMADD(KP618033988, Ti, Tl);
        Td            = T1 + SIMD_FNMADD(KP500000000, Tb + Tc, T2);
        Te            = Tb - Tc;
        Ta            = T6 + T9;
        Tq            = T6 - T9;
        Tf            = SIMD_FNMADD(KP1_118033988, Te, Td);
        Tn            = SIMD_FMADD(KP1_118033988, Te, Td);
        Tp            = SIMD_FNMADD(KP500000000, Ta, T3);
        R0[WS(rs, 4)] = SIMD_FMADD(KP2_000000000, Ta, T3);
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_902113032, Tm, Tf);
        R0[WS(rs, 7)] = SIMD_FNMADD(KP1_902113032, Tm, Tf);
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_902113032, To, Tn);
        R0[WS(rs, 5)] = SIMD_FNMADD(KP1_902113032, To, Tn);
        Tv            = SIMD_FNMADD(KP1_118033988, Tq, Tp);
        Tr            = SIMD_FMADD(KP1_118033988, Tq, Tp);
        R0[WS(rs, 2)] = SIMD_FNMADD(KP1_902113032, Tw, Tv);
        R0[WS(rs, 6)] = SIMD_FMADD(KP1_902113032, Tw, Tv);
        R0[WS(rs, 8)] = SIMD_FMADD(KP1_902113032, Tu, Tr);
        R0[0]         = SIMD_FNMADD(KP1_902113032, Tu, Tr);
    }
}

template <>
struct r2cb_traits<10, 2>
{
    static constexpr long_t flops           = 50;
    static constexpr long_t operations      = 32;
    static constexpr long_t memory_accesses = 18;
    static constexpr long_t stack_vars      = 38;
    static constexpr long_t constants       = 6;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 2 -name
 * r2cb -standalone */

/*
 * This function contains 32 FP additions, 18 FP multiplications,
 * (or, 14 additions, 0 multiplications, 18 fused multiply/add),
 * 38 stack variables, 6 constants, and 18 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 2>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT Tg, Th, Tj, Tk, T1, T2, T4, T5, T7, T8, Ti, Ts, Tl, Tt, T3;
        SIMD_FLOAT Tb, T6, Tc, T9, Tu, To, Tm, Td, Te, Tq, Ta, Tn, Tf, Tp, Tv;
        SIMD_FLOAT Tr, Tw;
        Tg            = Ci[WS(cs, 4)];
        Th            = Ci[WS(cs, 1)];
        Tj            = Ci[WS(cs, 2)];
        Tk            = Ci[WS(cs, 3)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        T4            = Cr[WS(cs, 2)];
        T5            = Cr[WS(cs, 3)];
        T7            = Cr[WS(cs, 4)];
        T8            = Cr[WS(cs, 1)];
        Ti            = Tg - Th;
        Ts            = Tg + Th;
        Tl            = Tj - Tk;
        Tt            = Tj + Tk;
        T3            = T1 - T2;
        Tb            = T4 + T5;
        T6            = T4 - T5;
        Tc            = T7 + T8;
        T9            = T7 - T8;
        Tu            = SIMD_FNMADD(KP618033988, Tt, Ts);
        To            = SIMD_FMADD(KP618033988, Ti, Tl);
        Tm            = SIMD_FNMADD(KP618033988, Tl, Ti);
        Td            = T1 + SIMD_FNMADD(KP500000000, Tb + Tc, T2);
        Te            = Tb - Tc;
        Tq            = T6 - T9;
        Ta            = T6 + T9;
        Tn            = SIMD_FMADD(KP1_118033988, Te, Td);
        Tf            = SIMD_FNMADD(KP1_118033988, Te, Td);
        Tp            = SIMD_FNMADD(KP500000000, Ta, T3);
        R0[WS(rs, 3)] = SIMD_FMADD(KP2_000000000, Ta, T3);
        Tv            = SIMD_FMADD(KP951056516, Tq, Ts);
        R0[0]         = SIMD_FMADD(KP1_902113032, Tm, Tf);
        R0[WS(rs, 6)] = SIMD_FNMADD(KP1_902113032, Tm, Tf);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, To, Tn);
        R0[WS(rs, 4)] = SIMD_FNMADD(KP1_902113032, To, Tn);
        Tr            = SIMD_FNMADD(KP1_118033988, Tq, Tp);
        Tw            = SIMD_FMADD(KP618033988, Tv, Tt);
        R0[WS(rs, 5)] = SIMD_FMADD(KP1_902113032, Tu, Tr);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP1_902113032, Tu, Tr);
        R0[WS(rs, 7)] = SIMD_FMADD(KP1_902113032, Tw, Tp);
    }
}

template <>
struct r2cb_traits<10, 3>
{
    static constexpr long_t flops           = 48;
    static constexpr long_t operations      = 31;
    static constexpr long_t memory_accesses = 17;
    static constexpr long_t stack_vars      = 39;
    static constexpr long_t constants       = 7;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 3 -name
 * r2cb -standalone */

/*
 * This function contains 31 FP additions, 17 FP multiplications,
 * (or, 14 additions, 0 multiplications, 17 fused multiply/add),
 * 39 stack variables, 7 constants, and 17 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 3>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP587785252, +0.587785252292473129168705954639072768597652438);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT Tg, Th, Tj, Tk, T1, T2, T4, T5, T7, T8, Ti, Tt, Tl, Ts, T3;
        SIMD_FLOAT Tb, T6, Tc, T9, Tu, Tm, Td, Te, Ta, Tq, Tf, Tn, Tp, Tv, To;
        SIMD_FLOAT Tr, Tw;
        Tg            = Ci[WS(cs, 2)];
        Th            = Ci[WS(cs, 3)];
        Tj            = Ci[WS(cs, 4)];
        Tk            = Ci[WS(cs, 1)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        T4            = Cr[WS(cs, 2)];
        T5            = Cr[WS(cs, 3)];
        T7            = Cr[WS(cs, 4)];
        T8            = Cr[WS(cs, 1)];
        Ti            = Tg - Th;
        Tt            = Tg + Th;
        Tl            = Tj - Tk;
        Ts            = Tj + Tk;
        T3            = T1 - T2;
        Tb            = T4 + T5;
        T6            = T4 - T5;
        Tc            = T7 + T8;
        T9            = T7 - T8;
        Tu            = SIMD_FNMADD(KP618033988, Tt, Ts);
        Tm            = SIMD_FMADD(KP618033988, Tl, Ti);
        Td            = T1 + SIMD_FNMADD(KP500000000, Tb + Tc, T2);
        Te            = Tb - Tc;
        Ta            = T6 + T9;
        Tq            = T6 - T9;
        Tf            = SIMD_FMADD(KP1_118033988, Te, Td);
        Tn            = SIMD_FMADD(KP587785252, Te, Tl);
        Tp            = SIMD_FNMADD(KP500000000, Ta, T3);
        R0[WS(rs, 2)] = SIMD_FMADD(KP2_000000000, Ta, T3);
        Tv            = SIMD_FMADD(KP951056516, Tq, Ts);
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_902113032, Tm, Tf);
        R0[WS(rs, 3)] = SIMD_FNMADD(KP1_902113032, Tm, Tf);
        To            = SIMD_FNMADD(KP618033988, Ti, Tn);
        Tr            = SIMD_FNMADD(KP1_118033988, Tq, Tp);
        Tw            = SIMD_FMADD(KP618033988, Tv, Tt);
        R0[WS(rs, 5)] = SIMD_FNMADD(KP1_902113032, To, Td);
        R0[WS(rs, 4)] = SIMD_FMADD(KP1_902113032, Tu, Tr);
        R0[0]         = SIMD_FNMADD(KP1_902113032, Tu, Tr);
        R0[WS(rs, 6)] = SIMD_FMADD(KP1_902113032, Tw, Tp);
    }
}

template <>
struct r2cb_traits<10, 4>
{
    static constexpr long_t flops           = 46;
    static constexpr long_t operations      = 30;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 39;
    static constexpr long_t constants       = 7;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 4 -name
 * r2cb -standalone */

/*
 * This function contains 30 FP additions, 16 FP multiplications,
 * (or, 14 additions, 0 multiplications, 16 fused multiply/add),
 * 39 stack variables, 7 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 4>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP587785252, +0.587785252292473129168705954639072768597652438);
    DK(KP1_118033988, +1.118033988749894848204586834365638117720309180);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    {
        SIMD_FLOAT Te, Tf, Tj, Tk, T1, T2, T4, T5, T7, T8, Tg, Tq, Tl, Tr, T3;
        SIMD_FLOAT Tb, T6, Tc, T9, To, Td, Th, Ts, Ta, Tn, Ti, Tp, Tt, Tv, Tm;
        SIMD_FLOAT Tu, Tw;
        Te            = Ci[WS(cs, 4)];
        Tf            = Ci[WS(cs, 1)];
        Tj            = Ci[WS(cs, 2)];
        Tk            = Ci[WS(cs, 3)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        T4            = Cr[WS(cs, 2)];
        T5            = Cr[WS(cs, 3)];
        T7            = Cr[WS(cs, 4)];
        T8            = Cr[WS(cs, 1)];
        Tg            = Te - Tf;
        Tq            = Te + Tf;
        Tl            = Tj - Tk;
        Tr            = Tj + Tk;
        T3            = T1 - T2;
        Tb            = T4 + T5;
        T6            = T4 - T5;
        Tc            = T7 + T8;
        T9            = T7 - T8;
        To            = SIMD_FMADD(KP618033988, Tg, Tl);
        Td            = T1 + SIMD_FNMADD(KP500000000, Tb + Tc, T2);
        Th            = Tb - Tc;
        Ts            = T6 - T9;
        Ta            = T6 + T9;
        Tn            = SIMD_FMADD(KP1_118033988, Th, Td);
        Ti            = SIMD_FMADD(KP587785252, Th, Tg);
        Tp            = SIMD_FNMADD(KP500000000, Ta, T3);
        R0[WS(rs, 1)] = SIMD_FMADD(KP2_000000000, Ta, T3);
        Tt            = SIMD_FMADD(KP951056516, Ts, Tr);
        Tv            = SIMD_FMADD(KP951056516, Ts, Tq);
        R0[0]         = SIMD_FMADD(KP1_902113032, To, Tn);
        R0[WS(rs, 2)] = SIMD_FNMADD(KP1_902113032, To, Tn);
        Tm            = SIMD_FNMADD(KP618033988, Tl, Ti);
        Tu            = SIMD_FNMADD(KP618033988, Tt, Tq);
        Tw            = SIMD_FMADD(KP618033988, Tv, Tr);
        R0[WS(rs, 4)] = SIMD_FNMADD(KP1_902113032, Tm, Td);
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_902113032, Tu, Tp);
        R0[WS(rs, 5)] = SIMD_FMADD(KP1_902113032, Tw, Tp);
    }
}

template <>
struct r2cb_traits<10, 5>
{
    static constexpr long_t flops           = 44;
    static constexpr long_t operations      = 29;
    static constexpr long_t memory_accesses = 15;
    static constexpr long_t stack_vars      = 37;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 5 -name
 * r2cb -standalone */

/*
 * This function contains 29 FP additions, 15 FP multiplications,
 * (or, 14 additions, 0 multiplications, 15 fused multiply/add),
 * 37 stack variables, 5 constants, and 15 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 5>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, Th, Ti, Te, Tf, T4, T5, T7, T8, T3, Tq, Tj, Tr, Tg;
        SIMD_FLOAT Tb, T6, Tc, T9, Td, Tk, Ts, Ta, Tl, Tn, Tt, Tv, Tp, Tm, To;
        SIMD_FLOAT Tu, Tw;
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        Th            = Ci[WS(cs, 1)];
        Ti            = Ci[WS(cs, 4)];
        Te            = Ci[WS(cs, 2)];
        Tf            = Ci[WS(cs, 3)];
        T4            = Cr[WS(cs, 2)];
        T5            = Cr[WS(cs, 3)];
        T7            = Cr[WS(cs, 4)];
        T8            = Cr[WS(cs, 1)];
        T3            = T1 - T2;
        Tq            = Ti + Th;
        Tj            = Th - Ti;
        Tr            = Te + Tf;
        Tg            = Te - Tf;
        Tb            = T4 + T5;
        T6            = T4 - T5;
        Tc            = T7 + T8;
        T9            = T7 - T8;
        Td            = T1 + SIMD_FNMADD(KP500000000, Tb + Tc, T2);
        Tk            = Tb - Tc;
        Ts            = T6 - T9;
        Ta            = T6 + T9;
        Tl            = SIMD_FMADD(KP951056516, Tk, Tj);
        Tn            = SIMD_FNMADD(KP951056516, Tk, Tg);
        Tt            = SIMD_FMADD(KP951056516, Ts, Tr);
        Tv            = SIMD_FMADD(KP951056516, Ts, Tq);
        Tp            = SIMD_FNMADD(KP500000000, Ta, T3);
        R0[0]         = SIMD_FMADD(KP2_000000000, Ta, T3);
        Tm            = SIMD_FNMADD(KP618033988, Tl, Tg);
        To            = SIMD_FMADD(KP618033988, Tn, Tj);
        Tu            = SIMD_FNMADD(KP618033988, Tt, Tq);
        Tw            = SIMD_FMADD(KP618033988, Tv, Tr);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP1_902113032, Tm, Td);
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_902113032, To, Td);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, Tu, Tp);
        R0[WS(rs, 4)] = SIMD_FMADD(KP1_902113032, Tw, Tp);
    }
}

template <>
struct r2cb_traits<10, 6>
{
    static constexpr long_t flops           = 42;
    static constexpr long_t operations      = 28;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 34;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 6 -name
 * r2cb -standalone */

/*
 * This function contains 28 FP additions, 14 FP multiplications,
 * (or, 14 additions, 0 multiplications, 14 fused multiply/add),
 * 34 stack variables, 4 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 6>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, Ta, Tb, Td, Te, T3, T4, T6, T7, Tc, Tp, Tf, To, T5;
        SIMD_FLOAT Tm, T8, Tl, Tn, Tq, T9, Tg, Tr, Tt, Th, Tj, Ts, Tu, Ti, Tk;
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        Ta            = Ci[WS(cs, 2)];
        Tb            = Ci[WS(cs, 3)];
        Td            = Ci[WS(cs, 1)];
        Te            = Ci[WS(cs, 4)];
        T3            = Cr[WS(cs, 2)];
        T4            = Cr[WS(cs, 3)];
        T6            = Cr[WS(cs, 4)];
        T7            = Cr[WS(cs, 1)];
        Tc            = Ta - Tb;
        Tp            = Ta + Tb;
        Tf            = Td - Te;
        To            = Te + Td;
        T5            = T3 + T4;
        Tm            = T3 - T4;
        T8            = T6 + T7;
        Tl            = T7 - T6;
        Tn            = SIMD_FMADD(KP500000000, Tl - Tm, T1) - T2;
        Tq            = Tm + Tl;
        T9            = T1 + SIMD_FNMADD(KP500000000, T5 + T8, T2);
        Tg            = T5 - T8;
        Tr            = SIMD_FMADD(KP951056516, Tq, Tp);
        Tt            = SIMD_FMADD(KP951056516, Tq, To);
        Th            = SIMD_FMADD(KP951056516, Tg, Tf);
        Tj            = SIMD_FNMADD(KP951056516, Tg, Tc);
        Ts            = SIMD_FNMADD(KP618033988, Tr, To);
        Tu            = SIMD_FMADD(KP618033988, Tt, Tp);
        Ti            = SIMD_FNMADD(KP618033988, Th, Tc);
        Tk            = SIMD_FMADD(KP618033988, Tj, Tf);
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_902113032, Ts, Tn);
        R0[WS(rs, 3)] = SIMD_FMADD(KP1_902113032, Tu, Tn);
        R0[0]         = SIMD_FNMADD(KP1_902113032, Ti, T9);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, Tk, T9);
    }
}

template <>
struct r2cb_traits<10, 7>
{
    static constexpr long_t flops           = 35;
    static constexpr long_t operations      = 23;
    static constexpr long_t memory_accesses = 13;
    static constexpr long_t stack_vars      = 32;
    static constexpr long_t constants       = 7;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 7 -name
 * r2cb -standalone */

/*
 * This function contains 23 FP additions, 12 FP multiplications,
 * (or, 11 additions, 0 multiplications, 12 fused multiply/add),
 * 32 stack variables, 7 constants, and 13 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 7>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP618033988, +0.618033988749894848204586834365638117720309180);
    DK(KP726542528, +0.726542528005360885895466757480618749616092393);
    DK(KP951056516, +0.951056516295153572116439333379382143405698634);
    DK(KP525731112, +0.525731112119133606025669084847876607285497932);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    DK(KP850650808, +0.850650808352039932181540497063011072240401404);
    {
        SIMD_FLOAT T1, T2, T3, T4, T5, T7, T8, T9, Tb, Tc, Tj, T6, Th, Tk, Ta;
        SIMD_FLOAT Tg, Td, Ti, Tl, Te, Tm, To, Tf, Tn, Tp;
        T1            = Cr[0];
        T2            = Cr[WS(cs, 5)];
        T3            = Ci[WS(cs, 1)];
        T4            = Ci[WS(cs, 4)];
        T5            = Cr[WS(cs, 2)];
        T7            = Cr[WS(cs, 3)];
        T8            = Ci[WS(cs, 2)];
        T9            = Ci[WS(cs, 3)];
        Tb            = Cr[WS(cs, 4)];
        Tc            = Cr[WS(cs, 1)];
        Tj            = T4 + T3;
        T6            = T3 - (SIMD_FMADD(KP850650808, T5, T4));
        Th            = T5 - T7;
        Tk            = T8 + T9;
        Ta            = T8 - T9;
        Tg            = Tc - Tb;
        Td            = Tb + Tc;
        Ti            = SIMD_FMADD(KP500000000, Tg - Th, T1) - T2;
        Tl            = Th + Tg;
        Te            = SIMD_FMADD(KP525731112, Td, Ta);
        Tm            = SIMD_FMADD(KP951056516, Tl, Tk);
        To            = SIMD_FMADD(KP951056516, Tl, Tj);
        Tf            = SIMD_FNMADD(KP726542528, Te, T7);
        Tn            = SIMD_FNMADD(KP618033988, Tm, Tj);
        Tp            = SIMD_FMADD(KP618033988, To, Tk);
        R0[WS(rs, 1)] = T1 + SIMD_FMADD(KP1_902113032,
                                        SIMD_FNMADD(KP850650808, Tf, T6), T2);
        R0[0]         = SIMD_FMADD(KP1_902113032, Tn, Ti);
        R0[WS(rs, 2)] = SIMD_FMADD(KP1_902113032, Tp, Ti);
    }
}

template <>
struct r2cb_traits<10, 8>
{
    static constexpr long_t flops           = 28;
    static constexpr long_t operations      = 18;
    static constexpr long_t memory_accesses = 12;
    static constexpr long_t stack_vars      = 25;
    static constexpr long_t constants       = 5;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 8 -name
 * r2cb -standalone */

/*
 * This function contains 18 FP additions, 10 FP multiplications,
 * (or, 8 additions, 0 multiplications, 10 fused multiply/add),
 * 25 stack variables, 5 constants, and 12 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 8>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_618033988, +1.618033988749894848204586834365638117720309180);
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP726542528, +0.726542528005360885895466757480618749616092393);
    DK(KP525731112, +0.525731112119133606025669084847876607285497932);
    DK(KP850650808, +0.850650808352039932181540497063011072240401404);
    {
        SIMD_FLOAT T1, T2, T3, T4, T5, T7, T8, T9, Tb, Tc, Th, T6, Ti, Tg, Ta;
        SIMD_FLOAT Td, Tj, Te, Tk, Tf;
        T1 = Cr[0];
        T2 = Cr[WS(cs, 5)];
        T3 = Ci[WS(cs, 1)];
        T4 = Ci[WS(cs, 4)];
        T5 = Cr[WS(cs, 2)];
        T7 = Cr[WS(cs, 3)];
        T8 = Ci[WS(cs, 2)];
        T9 = Ci[WS(cs, 3)];
        Tb = Cr[WS(cs, 4)];
        Tc = Cr[WS(cs, 1)];
        Th = T4 + T3;
        T6 = T3 - (SIMD_FMADD(KP850650808, T5, T4));
        Ti = T5 - T7;
        Tg = T8 + T9;
        Ta = T8 - T9;
        Td = Tb + Tc;
        Tj = SIMD_FMADD(KP525731112, Ti, Th);
        Te = SIMD_FMADD(KP525731112, Td, Ta);
        Tk = SIMD_FMADD(KP726542528, Tj, Tc);
        Tf = SIMD_FNMADD(KP726542528, Te, T7);
        R0[WS(rs, 1)] =
            SIMD_FMADD(KP1_902113032, SIMD_FMADD(KP850650808, Tk, Tg), T1) -
            (SIMD_FMADD(KP1_618033988, Tb, T2));
        R0[0] = T1 +
                SIMD_FMADD(KP1_902113032, SIMD_FNMADD(KP850650808, Tf, T6), T2);
    }
}

template <>
struct r2cb_traits<10, 9>
{
    static constexpr long_t flops           = 13;
    static constexpr long_t operations      = 9;
    static constexpr long_t memory_accesses = 11;
    static constexpr long_t stack_vars      = 20;
    static constexpr long_t constants       = 4;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 10 -skip-k 9 -name
 * r2cb -standalone */

/*
 * This function contains 9 FP additions, 4 FP multiplications,
 * (or, 5 additions, 0 multiplications, 4 fused multiply/add),
 * 20 stack variables, 4 constants, and 11 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 10 && SkippedOutputs == 9>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP850650808, +0.850650808352039932181540497063011072240401404);
    DK(KP1_902113032, +1.902113032590307144232878666758764286811397268);
    DK(KP726542528, +0.726542528005360885895466757480618749616092393);
    DK(KP525731112, +0.525731112119133606025669084847876607285497932);
    {
        SIMD_FLOAT T1, Tg, T2, T3, T5, T6, T8, T9, Tb, Tc, T4, T7, Ta, Td, Te;
        SIMD_FLOAT Tf;
        T1 = Cr[0];
        Tg = Cr[WS(cs, 5)];
        T2 = Ci[WS(cs, 2)];
        T3 = Ci[WS(cs, 3)];
        T5 = Cr[WS(cs, 1)];
        T6 = Cr[WS(cs, 4)];
        T8 = Ci[WS(cs, 4)];
        T9 = Ci[WS(cs, 1)];
        Tb = Cr[WS(cs, 2)];
        Tc = Cr[WS(cs, 3)];
        T4 = T2 + T3;
        T7 = T5 - T6;
        Ta = T8 + T9;
        Td = Tb - Tc;
        Te = SIMD_FMADD(KP525731112, Td, Ta);
        Tf = SIMD_FMADD(KP726542528, Te, T7);
        R0[0] =
            SIMD_FMADD(KP1_902113032, SIMD_FMADD(KP850650808, Tf, T4), T1) - Tg;
    }
}
