//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct c2cf_traits<4, 1>
{
    static constexpr long_t flops           = 0;
    static constexpr long_t operations      = 0;
    static constexpr long_t memory_accesses = 10;
    static constexpr long_t stack_vars      = 2;
    static constexpr long_t constants       = 0;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 4 -first-k 1 -name c2cf
 * -standalone */

/*
 * This function contains 0 FP additions, 0 FP multiplications,
 * (or, 0 additions, 0 multiplications, 0 fused multiply/add),
 * 2 stack variables, 0 constants, and 10 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 4 && ProvidedElements == 1>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    {
        SIMD_FLOAT T1, T2;
        T1            = ri[0];
        T2            = ii[0];
        ro[WS(os, 2)] = T1;
        ro[WS(os, 1)] = T1;
        ro[WS(os, 3)] = T1;
        ro[0]         = T1;
        io[WS(os, 2)] = T2;
        io[WS(os, 1)] = T2;
        io[WS(os, 3)] = T2;
        io[0]         = T2;
    }
}

template <>
struct c2cf_traits<4, 2>
{
    static constexpr long_t flops           = 8;
    static constexpr long_t operations      = 8;
    static constexpr long_t memory_accesses = 12;
    static constexpr long_t stack_vars      = 4;
    static constexpr long_t constants       = 0;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 4 -first-k 2 -name c2cf
 * -standalone */

/*
 * This function contains 8 FP additions, 0 FP multiplications,
 * (or, 8 additions, 0 multiplications, 0 fused multiply/add),
 * 4 stack variables, 0 constants, and 12 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 4 && ProvidedElements == 2>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    {
        SIMD_FLOAT T1, T3, T2, T4;
        T1            = ri[0];
        T3            = ii[0];
        T2            = ri[WS(is, 1)];
        T4            = ii[WS(is, 1)];
        io[WS(os, 3)] = T2 + T3;
        io[WS(os, 1)] = T3 - T2;
        ro[0]         = T1 + T2;
        ro[WS(os, 2)] = T1 - T2;
        ro[WS(os, 3)] = T1 - T4;
        ro[WS(os, 1)] = T1 + T4;
        io[0]         = T3 + T4;
        io[WS(os, 2)] = T3 - T4;
    }
}

template <>
struct c2cf_traits<4, 3>
{
    static constexpr long_t flops           = 12;
    static constexpr long_t operations      = 12;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 10;
    static constexpr long_t constants       = 0;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 4 -first-k 3 -name c2cf
 * -standalone */

/*
 * This function contains 12 FP additions, 0 FP multiplications,
 * (or, 12 additions, 0 multiplications, 0 fused multiply/add),
 * 10 stack variables, 0 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 4 && ProvidedElements == 3>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    {
        SIMD_FLOAT T4, T9, T1, T2, T5, T6, T3, Ta, T7, T8;
        T4            = ri[WS(is, 1)];
        T9            = ii[WS(is, 1)];
        T1            = ri[0];
        T2            = ri[WS(is, 2)];
        T5            = ii[0];
        T6            = ii[WS(is, 2)];
        T3            = T1 + T2;
        Ta            = T1 - T2;
        T7            = T5 - T6;
        T8            = T5 + T6;
        ro[WS(os, 3)] = Ta - T9;
        ro[WS(os, 1)] = Ta + T9;
        ro[0]         = T3 + T4;
        ro[WS(os, 2)] = T3 - T4;
        io[0]         = T8 + T9;
        io[WS(os, 2)] = T8 - T9;
        io[WS(os, 3)] = T4 + T7;
        io[WS(os, 1)] = T7 - T4;
    }
}

template <>
struct c2cf_traits<4, 4>
{
    static constexpr long_t flops           = 16;
    static constexpr long_t operations      = 16;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 16;
    static constexpr long_t constants       = 0;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 4 -first-k 4 -name c2cf
 * -standalone */

/*
 * This function contains 16 FP additions, 0 FP multiplications,
 * (or, 16 additions, 0 multiplications, 0 fused multiply/add),
 * 16 stack variables, 0 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 4 && ProvidedElements == 4>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    {
        SIMD_FLOAT T1, T2, T7, T8, T4, T5, Tc, Td, T3, Tb, T9, Tf, T6, Ta, Te;
        SIMD_FLOAT Tg;
        T1            = ri[0];
        T2            = ri[WS(is, 2)];
        T7            = ii[0];
        T8            = ii[WS(is, 2)];
        T4            = ri[WS(is, 1)];
        T5            = ri[WS(is, 3)];
        Tc            = ii[WS(is, 1)];
        Td            = ii[WS(is, 3)];
        T3            = T1 + T2;
        Tb            = T1 - T2;
        T9            = T7 - T8;
        Tf            = T7 + T8;
        T6            = T4 + T5;
        Ta            = T4 - T5;
        Te            = Tc - Td;
        Tg            = Tc + Td;
        io[WS(os, 3)] = Ta + T9;
        io[WS(os, 1)] = T9 - Ta;
        ro[0]         = T3 + T6;
        ro[WS(os, 2)] = T3 - T6;
        io[0]         = Tf + Tg;
        io[WS(os, 2)] = Tf - Tg;
        ro[WS(os, 3)] = Tb - Te;
        ro[WS(os, 1)] = Tb + Te;
    }
}
