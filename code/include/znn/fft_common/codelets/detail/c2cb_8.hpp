//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct c2cb_traits<8, 0>
{
    static constexpr long_t flops           = 60;
    static constexpr long_t operations      = 52;
    static constexpr long_t memory_accesses = 32;
    static constexpr long_t stack_vars      = 53;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 0 -name c2cb
 * -standalone */

/*
 * This function contains 52 FP additions, 8 FP multiplications,
 * (or, 44 additions, 0 multiplications, 8 fused multiply/add),
 * 53 stack variables, 1 constants, and 32 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 0>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T8, Tn, T3, TC, Ti, TB, T6, To, Tl, Td, Tv, TN, Ty, T9, Tr;
        SIMD_FLOAT Ts, T1, T2, Tg, Th, T4, T5, Tj, Tk, Tb, Tc, Tw, Tx, TJ, TD;
        SIMD_FLOAT T7, TL, Tp, TF, TP, Tm, Tz, TH, Tq, Ta, Tt, TM, Te, Tf, TQ;
        SIMD_FLOAT TO, Tu, TG, TK, TI, TA, TE;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tg            = ii[0];
        Th            = ii[WS(is, 4)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 6)];
        Tj            = ii[WS(is, 2)];
        Tk            = ii[WS(is, 6)];
        Tb            = ri[WS(is, 7)];
        Tc            = ri[WS(is, 3)];
        Tw            = ii[WS(is, 7)];
        Tx            = ii[WS(is, 3)];
        T8            = ri[WS(is, 1)];
        Tn            = T1 - T2;
        T3            = T1 + T2;
        TC            = Tg - Th;
        Ti            = Tg + Th;
        TB            = T4 - T5;
        T6            = T4 + T5;
        To            = Tj - Tk;
        Tl            = Tj + Tk;
        Td            = Tb + Tc;
        Tv            = Tb - Tc;
        TN            = Tw + Tx;
        Ty            = Tw - Tx;
        T9            = ri[WS(is, 5)];
        Tr            = ii[WS(is, 1)];
        Ts            = ii[WS(is, 5)];
        TJ            = TC - TB;
        TD            = TB + TC;
        T7            = T3 + T6;
        TL            = T3 - T6;
        Tp            = Tn + To;
        TF            = Tn - To;
        TP            = Ti + Tl;
        Tm            = Ti - Tl;
        Tz            = Tv - Ty;
        TH            = Tv + Ty;
        Tq            = T8 - T9;
        Ta            = T8 + T9;
        Tt            = Tr - Ts;
        TM            = Tr + Ts;
        Te            = Ta + Td;
        Tf            = Td - Ta;
        TQ            = TM + TN;
        TO            = TM - TN;
        Tu            = Tq + Tt;
        TG            = Tt - Tq;
        io[WS(os, 6)] = Tm - Tf;
        io[WS(os, 2)] = Tf + Tm;
        ro[0]         = T7 + Te;
        ro[WS(os, 4)] = T7 - Te;
        ro[WS(os, 2)] = TL + TO;
        ro[WS(os, 6)] = TL - TO;
        io[0]         = TP + TQ;
        io[WS(os, 4)] = TP - TQ;
        TK            = TG + TH;
        TI            = TG - TH;
        TA            = Tu + Tz;
        TE            = Tz - Tu;
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, TI, TF);
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, TI, TF);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, TK, TJ);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, TK, TJ);
        io[WS(os, 3)] = SIMD_FMADD(KP707106781, TE, TD);
        io[WS(os, 7)] = SIMD_FNMADD(KP707106781, TE, TD);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, TA, Tp);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, TA, Tp);
    }
}

template <>
struct c2cb_traits<8, 1>
{
    static constexpr long_t flops           = 60;
    static constexpr long_t operations      = 52;
    static constexpr long_t memory_accesses = 30;
    static constexpr long_t stack_vars      = 47;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 1 -name c2cb
 * -standalone */

/*
 * This function contains 52 FP additions, 8 FP multiplications,
 * (or, 44 additions, 0 multiplications, 8 fused multiply/add),
 * 47 stack variables, 1 constants, and 30 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 1>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT Ti, Tj, T8, TI, T3, Tz, Tv, Tw, T6, TJ, TC, Tr, Th, Tk, T9;
        SIMD_FLOAT Tb, Tc, T1, T2, Tt, Tu, T4, T5, TA, TB, Tf, Tg, Tx, T7, Tn;
        SIMD_FLOAT TK, TF, TD, Tp, Tl, Ts, Ta, Td, Ty, TH, Te, To, TE, Tq, Tm;
        SIMD_FLOAT TG;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tt            = ii[0];
        Tu            = ii[WS(is, 4)];
        T4            = ii[WS(is, 2)];
        T5            = ii[WS(is, 6)];
        TA            = ri[WS(is, 2)];
        TB            = ri[WS(is, 6)];
        Tf            = ri[WS(is, 7)];
        Tg            = ri[WS(is, 3)];
        Ti            = ii[WS(is, 7)];
        Tj            = ii[WS(is, 3)];
        T8            = ri[WS(is, 1)];
        TI            = T1 + T2;
        T3            = T1 - T2;
        Tz            = Tt - Tu;
        Tv            = Tt + Tu;
        Tw            = T4 + T5;
        T6            = T4 - T5;
        TJ            = TA + TB;
        TC            = TA - TB;
        Tr            = Tf + Tg;
        Th            = Tf - Tg;
        Tk            = Ti - Tj;
        T9            = ri[WS(is, 5)];
        Tb            = ii[WS(is, 1)];
        Tc            = ii[WS(is, 5)];
        Tx            = Tv - Tw;
        T7            = T3 + T6;
        Tn            = T3 - T6;
        TK            = TI - TJ;
        TF            = Tz + TC;
        TD            = Tz - TC;
        Tp            = Th + Tk;
        Tl            = Th - Tk;
        Ts            = Tr - (T8 + T9);
        ro[WS(os, 3)] = TI + TJ - Tr - (T8 + T9);
        Ta            = T8 - T9;
        Td            = Tb - Tc;
        Ty            = Tb + Tc;
        io[WS(os, 5)] = Tx - Ts;
        io[WS(os, 1)] = Ts + Tx;
        TH            = Ty - (Ti + Tj);
        io[WS(os, 3)] = Tw + Tv - (Ti + Tj) - Ty;
        Te            = Ta + Td;
        To            = Td - Ta;
        ro[WS(os, 5)] = TK - TH;
        ro[WS(os, 1)] = TH + TK;
        TE            = To + Tp;
        Tq            = To - Tp;
        Tm            = Te + Tl;
        TG            = Tl - Te;
        ro[WS(os, 2)] = SIMD_FMADD(KP707106781, Tq, Tn);
        ro[WS(os, 6)] = SIMD_FNMADD(KP707106781, Tq, Tn);
        io[WS(os, 4)] = SIMD_FNMADD(KP707106781, TE, TD);
        io[0]         = SIMD_FMADD(KP707106781, TE, TD);
        io[WS(os, 6)] = SIMD_FNMADD(KP707106781, TG, TF);
        io[WS(os, 2)] = SIMD_FMADD(KP707106781, TG, TF);
        ro[0]         = SIMD_FMADD(KP707106781, Tm, T7);
        ro[WS(os, 4)] = SIMD_FNMADD(KP707106781, Tm, T7);
    }
}

template <>
struct c2cb_traits<8, 2>
{
    static constexpr long_t flops           = 57;
    static constexpr long_t operations      = 50;
    static constexpr long_t memory_accesses = 28;
    static constexpr long_t stack_vars      = 43;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 2 -name c2cb
 * -standalone */

/*
 * This function contains 50 FP additions, 7 FP multiplications,
 * (or, 43 additions, 0 multiplications, 7 fused multiply/add),
 * 43 stack variables, 1 constants, and 28 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 2>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT Tb, Tc, T8, Tw, T3, Tk, Tg, Tq, T6, Tx, Tj, Tl, T9, TF, To;
        SIMD_FLOAT Ts, Tt, T1, T2, Te, Tf, T4, T5, Th, Ti, Tm, Tn, TA, T7, Ty;
        SIMD_FLOAT TE, Ta, Tr, TB, Tp, TG, Tu, Td, TC, Tv, Tz, TD;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Te            = ii[0];
        Tf            = ii[WS(is, 4)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 6)];
        Th            = ii[WS(is, 2)];
        Ti            = ii[WS(is, 6)];
        Tb            = ii[WS(is, 7)];
        Tc            = ii[WS(is, 3)];
        Tm            = ri[WS(is, 7)];
        Tn            = ri[WS(is, 3)];
        T8            = ii[WS(is, 1)];
        Tw            = T1 - T2;
        T3            = T1 + T2;
        Tk            = Te - Tf;
        Tg            = Te + Tf;
        Tq            = T4 - T5;
        T6            = T4 + T5;
        Tx            = Th - Ti;
        Tj            = Th + Ti;
        Tl            = Tc - Tb;
        T9            = ii[WS(is, 5)];
        TF            = Tm + Tn;
        To            = Tm - Tn;
        Ts            = ri[WS(is, 5)];
        Tt            = ri[WS(is, 1)];
        TA            = Tq + Tk;
        T7            = T3 - T6;
        Ty            = Tw - Tx;
        TE            = Tg - Tj;
        Ta            = T8 + T9;
        Tr            = T8 - T9;
        TB            = Tl + To;
        Tp            = Tl - To;
        TG            = TF - (Ts + Tt);
        ro[WS(os, 2)] = T3 + T6 - (Ts + Tt) - TF;
        Tu            = Ts - Tt;
        Td            = Ta - (Tb + Tc);
        io[WS(os, 2)] = Tg + Tj - (Tb + Tc) - Ta;
        io[0]         = TE + TG;
        io[WS(os, 4)] = TE - TG;
        TC            = Tu - Tr;
        Tv            = Tr + Tu;
        ro[0]         = T7 + Td;
        ro[WS(os, 4)] = T7 - Td;
        Tz            = Tp + Tv;
        io[WS(os, 3)] =
            SIMD_FMADD(KP707106781, Tp, Tk) - (SIMD_FMADD(KP707106781, Tv, Tq));
        TD            = TB + TC;
        ro[WS(os, 3)] = Tw + SIMD_FMADD(KP707106781, TC - TB, Tx);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, Tz, Ty);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tz, Ty);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, TD, TA);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, TD, TA);
    }
}

template <>
struct c2cb_traits<8, 3>
{
    static constexpr long_t flops           = 55;
    static constexpr long_t operations      = 48;
    static constexpr long_t memory_accesses = 26;
    static constexpr long_t stack_vars      = 39;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 3 -name c2cb
 * -standalone */

/*
 * This function contains 48 FP additions, 7 FP multiplications,
 * (or, 41 additions, 0 multiplications, 7 fused multiply/add),
 * 39 stack variables, 1 constants, and 26 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 3>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT Ti, Tj, T8, TB, T3, Tv, Ts, Tp, T6, TC, Ty, Tt, Th, Tk, T9;
        SIMD_FLOAT Tb, Tc, T1, T2, Tq, Tr, T4, T5, Tw, Tx, Tf, Tg, T7, Tz, To;
        SIMD_FLOAT Tl, Ta, Td, Tu, Te, Tn, TA, Tm;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tq            = ii[0];
        Tr            = ii[WS(is, 4)];
        T4            = ii[WS(is, 2)];
        T5            = ii[WS(is, 6)];
        Tw            = ri[WS(is, 2)];
        Tx            = ri[WS(is, 6)];
        Tf            = ii[WS(is, 3)];
        Tg            = ii[WS(is, 7)];
        Ti            = ri[WS(is, 7)];
        Tj            = ri[WS(is, 3)];
        T8            = ii[WS(is, 1)];
        TB            = T1 + T2;
        T3            = T1 - T2;
        Tv            = Tq - Tr;
        Ts            = Tq + Tr;
        Tp            = T4 + T5;
        T6            = T4 - T5;
        TC            = Tw + Tx;
        Ty            = Tw - Tx;
        Tt            = Tf + Tg;
        Th            = Tf - Tg;
        Tk            = Ti - Tj;
        T9            = ii[WS(is, 5)];
        Tb            = ri[WS(is, 5)];
        Tc            = ri[WS(is, 1)];
        T7            = T3 - T6;
        Tz            = Tv + Ty;
        To            = Th + Tk;
        Tl            = Th - Tk;
        ro[WS(os, 3)] = TB + Tt - TC - (T8 + T9);
        io[WS(os, 1)] = Tp + Ts - Tt - (T8 + T9);
        Ta            = T8 - T9;
        Td            = Tb - Tc;
        Tu            = Tb + Tc;
        io[WS(os, 3)] = Tu + Ts - (Ti + Tj) - Tp;
        ro[WS(os, 1)] = TB + TC - (Ti + Tj) - Tu;
        Te            = Ta + Td;
        Tn            = Td - Ta;
        TA            = Tn + To;
        ro[WS(os, 2)] = T3 + SIMD_FMADD(KP707106781, Tn - To, T6);
        Tm            = Te + Tl;
        io[WS(os, 2)] =
            SIMD_FMADD(KP707106781, Tl, Tv) - (SIMD_FMADD(KP707106781, Te, Ty));
        io[WS(os, 4)] = SIMD_FNMADD(KP707106781, TA, Tz);
        io[0]         = SIMD_FMADD(KP707106781, TA, Tz);
        ro[0]         = SIMD_FMADD(KP707106781, Tm, T7);
        ro[WS(os, 4)] = SIMD_FNMADD(KP707106781, Tm, T7);
    }
}

template <>
struct c2cb_traits<8, 4>
{
    static constexpr long_t flops           = 51;
    static constexpr long_t operations      = 46;
    static constexpr long_t memory_accesses = 24;
    static constexpr long_t stack_vars      = 35;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 4 -name c2cb
 * -standalone */

/*
 * This function contains 46 FP additions, 5 FP multiplications,
 * (or, 41 additions, 0 multiplications, 5 fused multiply/add),
 * 35 stack variables, 1 constants, and 24 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 4>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT Ta, Tb, Tk, Tl, Tp, Tm, Tf, Tj, T9, Ty, Ts, Tu, T3, Ti, Te;
        SIMD_FLOAT Tg, T6, To, T7, T8, Tq, Tr, T1, T2, Tc, Td, T4, T5, Tx, Tn;
        SIMD_FLOAT Tw, Tt, Th, Tv;
        Ta            = ri[WS(is, 7)];
        Tb            = ri[WS(is, 3)];
        Tk            = ii[WS(is, 1)];
        Tl            = ii[WS(is, 5)];
        T7            = ri[WS(is, 1)];
        T8            = ri[WS(is, 5)];
        Tq            = ii[WS(is, 7)];
        Tr            = ii[WS(is, 3)];
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tc            = ii[0];
        Td            = ii[WS(is, 4)];
        T4            = ri[WS(is, 2)];
        Tp            = Ta - Tb;
        T5            = ri[WS(is, 6)];
        Tm            = Tk - Tl;
        Tf            = ii[WS(is, 2)];
        Tj            = T7 - T8;
        T9            = T7 + T8;
        Ty            = Tq + Tr;
        Ts            = Tq - Tr;
        Tu            = T1 - T2;
        T3            = T1 + T2;
        Ti            = Tc - Td;
        Te            = Tc + Td;
        Tg            = ii[WS(is, 6)];
        T6            = T4 + T5;
        To            = T4 - T5;
        Tx            = Tj + Tm;
        Tn            = Tj - Tm;
        Tw            = Ts - Tp;
        Tt            = Tp + Ts;
        Th            = Tf + Tg;
        Tv            = Tf - Tg;
        ro[WS(os, 2)] = T3 + Ty - (Tk + Tl) - T6;
        ro[0]         = T3 + T6 - T9 - (Ta + Tb);
        io[WS(os, 1)] =
            SIMD_FMADD(KP707106781, Tn, Ti) - (SIMD_FMADD(KP707106781, Tt, To));
        io[WS(os, 3)] = To + SIMD_FMADD(KP707106781, Tw + Tx, Ti);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, Tt + Tn, Tu) - Tv;
        ro[WS(os, 1)] = Tu + SIMD_FMADD(KP707106781, Tw - Tx, Tv);
        io[WS(os, 2)] = T9 + Te - Th - (Ta + Tb);
        io[0]         = Te + Th - (Tk + Tl) - Ty;
    }
}

template <>
struct c2cb_traits<8, 5>
{
    static constexpr long_t flops           = 43;
    static constexpr long_t operations      = 38;
    static constexpr long_t memory_accesses = 22;
    static constexpr long_t stack_vars      = 29;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 5 -name c2cb
 * -standalone */

/*
 * This function contains 38 FP additions, 5 FP multiplications,
 * (or, 33 additions, 0 multiplications, 5 fused multiply/add),
 * 29 stack variables, 1 constants, and 22 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 5>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T2, Tn, To, T4, T5, T7, T8, Tb, Tc, Te, Tf, Ti, T3, Tj;
        SIMD_FLOAT Tp, Tq, T6, Tr, T9, Td, Tg, Tk, Ts, Ta, Tl, Th, Tm;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tn            = ii[0];
        To            = ii[WS(is, 4)];
        T4            = ii[WS(is, 7)];
        T5            = ii[WS(is, 3)];
        T7            = ri[WS(is, 7)];
        T8            = ri[WS(is, 3)];
        Tb            = ri[WS(is, 1)];
        Tc            = ri[WS(is, 5)];
        Te            = ii[WS(is, 1)];
        Tf            = ii[WS(is, 5)];
        Ti            = ii[WS(is, 2)];
        T3            = T1 - T2;
        Tj            = ii[WS(is, 6)];
        Tp            = Tn - To;
        Tq            = ri[WS(is, 2)];
        T6            = T4 - T5;
        Tr            = ri[WS(is, 6)];
        T9            = T7 - T8;
        Td            = Tb - Tc;
        Tg            = Te - Tf;
        io[WS(os, 1)] = Tb + Tc + Tn + To - Tj - Ti - T8 - T7;
        Tk            = Ti - Tj;
        ro[WS(os, 1)] = T1 + T2 + T4 + T5 - Tr - Tq - Tf - Te;
        Ts            = Tq - Tr;
        Ta            = T6 + T9;
        Tl            = T6 - T9;
        Th            = Td - Tg;
        Tm            = Td + Tg;
        io[WS(os, 2)] = SIMD_FMADD(KP707106781, Tl + Tm, Tp) + Ts;
        ro[0]         = SIMD_FMADD(KP707106781, Tl - Tm, T3) + Tk;
        io[0] =
            SIMD_FMADD(KP707106781, Th, Tp) - (SIMD_FMADD(KP707106781, Ta, Ts));
        ro[WS(os, 2)] = SIMD_FMADD(KP707106781, Ta + Th, T3) - Tk;
    }
}

template <>
struct c2cb_traits<8, 6>
{
    static constexpr long_t flops           = 33;
    static constexpr long_t operations      = 30;
    static constexpr long_t memory_accesses = 20;
    static constexpr long_t stack_vars      = 19;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 6 -name c2cb
 * -standalone */

/*
 * This function contains 30 FP additions, 3 FP multiplications,
 * (or, 27 additions, 0 multiplications, 3 fused multiply/add),
 * 19 stack variables, 1 constants, and 20 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 6>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T9, T2, Ta, T5, Tg, Te, T8, T3, Tc, T4, Tb, T6, Tf, T7;
        SIMD_FLOAT Td, Th, Ti;
        T1            = ri[0];
        T9            = ii[0];
        T2            = ri[WS(is, 4)];
        Ta            = ii[WS(is, 4)];
        T5            = ri[WS(is, 2)];
        Tg            = ii[WS(is, 2)];
        Te            = ii[WS(is, 6)];
        T8            = ri[WS(is, 6)];
        T3            = ii[WS(is, 7)];
        Tc            = ri[WS(is, 5)];
        T4            = ii[WS(is, 3)];
        Tb            = ri[WS(is, 1)];
        T6            = ii[WS(is, 5)];
        Tf            = ri[WS(is, 7)];
        T7            = ii[WS(is, 1)];
        Td            = ri[WS(is, 3)];
        Th            = T3 + Tb - (T4 + Tc);
        ro[0]         = T1 + T2 + T3 + T4 - (T5 + T6) - T7 - T8;
        io[0]         = T9 + Ta + Tb + Tc - Td - (Te + Tf) - Tg;
        Ti            = T6 + Tf - Td - T7;
        ro[WS(os, 1)] = T1 + SIMD_FMADD(KP707106781, Th + Ti, Te) - Tg - T2;
        io[WS(os, 1)] = T5 + SIMD_FMADD(KP707106781, Th, T9) -
                        (SIMD_FMADD(KP707106781, Ti, Ta)) - T8;
    }
}

template <>
struct c2cb_traits<8, 7>
{
    static constexpr long_t flops           = 19;
    static constexpr long_t operations      = 16;
    static constexpr long_t memory_accesses = 18;
    static constexpr long_t stack_vars      = 19;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -skip-k 7 -name c2cb
 * -standalone */

/*
 * This function contains 16 FP additions, 3 FP multiplications,
 * (or, 13 additions, 0 multiplications, 3 fused multiply/add),
 * 19 stack variables, 1 constants, and 18 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 7>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, Tf, T2, Ti, Td, Th, Tg, Te, T3, T6, T4, T5, T8, Tb, T9;
        SIMD_FLOAT Ta, T7, Tc;
        T1    = ri[0];
        Tf    = ii[0];
        T2    = ii[WS(is, 6)];
        Ti    = ri[WS(is, 6)];
        Td    = ri[WS(is, 4)];
        Th    = ii[WS(is, 4)];
        Tg    = ri[WS(is, 2)];
        Te    = ii[WS(is, 2)];
        T3    = ii[WS(is, 5)];
        T6    = ri[WS(is, 3)];
        T4    = ri[WS(is, 7)];
        T5    = ii[WS(is, 1)];
        T8    = ri[WS(is, 1)];
        Tb    = ii[WS(is, 3)];
        T9    = ii[WS(is, 7)];
        Ta    = ri[WS(is, 5)];
        T7    = T3 + T4 - (T5 + T6);
        Tc    = T8 + T9 - (Ta + Tb);
        io[0] = SIMD_FMADD(KP707106781, Tc, Tf) + Tg -
                (SIMD_FMADD(KP707106781, T7, Th) + Ti);
        ro[0] = T1 + SIMD_FMADD(KP707106781, T7 + Tc, T2) - (Td + Te);
    }
}
