//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct c2cb_traits<6, 0>
{
    static constexpr long_t flops           = 48;
    static constexpr long_t operations      = 36;
    static constexpr long_t memory_accesses = 24;
    static constexpr long_t stack_vars      = 38;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 6 -skip-k 0 -name c2cb
 * -standalone */

/*
 * This function contains 36 FP additions, 12 FP multiplications,
 * (or, 24 additions, 0 multiplications, 12 fused multiply/add),
 * 38 stack variables, 2 constants, and 24 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 6 && SkippedOutputs == 0>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, Tn, To, T4, T5, T7, T8, Tg, Th, Tj, Tk, T3, Tb, Tp;
        SIMD_FLOAT Tx, T6, Tc, T9, Td, Ti, Tu, Tl, Tv, Te, TA, Ta, Ts, Ty, Tw;
        SIMD_FLOAT Tq, Tm, Tt, Tf, Tz, Tr;
        T1            = ri[0];
        T2            = ri[WS(is, 3)];
        Tn            = ii[0];
        To            = ii[WS(is, 3)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 5)];
        T7            = ri[WS(is, 4)];
        T8            = ri[WS(is, 1)];
        Tg            = ii[WS(is, 2)];
        Th            = ii[WS(is, 5)];
        Tj            = ii[WS(is, 4)];
        Tk            = ii[WS(is, 1)];
        T3            = T1 - T2;
        Tb            = T1 + T2;
        Tp            = Tn - To;
        Tx            = Tn + To;
        T6            = T4 - T5;
        Tc            = T4 + T5;
        T9            = T7 - T8;
        Td            = T7 + T8;
        Ti            = Tg - Th;
        Tu            = Tg + Th;
        Tl            = Tj - Tk;
        Tv            = Tj + Tk;
        Te            = Tc + Td;
        TA            = Td - Tc;
        Ta            = T6 + T9;
        Ts            = T9 - T6;
        Ty            = Tu + Tv;
        Tw            = Tu - Tv;
        Tq            = Ti + Tl;
        Tm            = Ti - Tl;
        Tt            = SIMD_FNMADD(KP500000000, Te, Tb);
        ro[0]         = Tb + Te;
        Tf            = SIMD_FNMADD(KP500000000, Ta, T3);
        ro[WS(os, 3)] = T3 + Ta;
        Tz            = SIMD_FNMADD(KP500000000, Ty, Tx);
        io[0]         = Tx + Ty;
        Tr            = SIMD_FNMADD(KP500000000, Tq, Tp);
        io[WS(os, 3)] = Tp + Tq;
        ro[WS(os, 4)] = SIMD_FMADD(KP866025403, Tw, Tt);
        ro[WS(os, 2)] = SIMD_FNMADD(KP866025403, Tw, Tt);
        ro[WS(os, 1)] = SIMD_FMADD(KP866025403, Tm, Tf);
        ro[WS(os, 5)] = SIMD_FNMADD(KP866025403, Tm, Tf);
        io[WS(os, 4)] = SIMD_FMADD(KP866025403, TA, Tz);
        io[WS(os, 2)] = SIMD_FNMADD(KP866025403, TA, Tz);
        io[WS(os, 5)] = SIMD_FNMADD(KP866025403, Ts, Tr);
        io[WS(os, 1)] = SIMD_FMADD(KP866025403, Ts, Tr);
    }
}

template <>
struct c2cb_traits<6, 1>
{
    static constexpr long_t flops           = 46;
    static constexpr long_t operations      = 34;
    static constexpr long_t memory_accesses = 22;
    static constexpr long_t stack_vars      = 34;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 6 -skip-k 1 -name c2cb
 * -standalone */

/*
 * This function contains 34 FP additions, 12 FP multiplications,
 * (or, 22 additions, 0 multiplications, 12 fused multiply/add),
 * 34 stack variables, 2 constants, and 22 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 6 && SkippedOutputs == 1>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, Tp, Tq, T4, T5, T7, T8, Tc, Td, Tf, Tg, T3, Tr, T6;
        SIMD_FLOAT Tj, T9, Tk, Te, Tm, Th, Tn, Tl, Tw, Ta, Tu, To, Tv, Ts, Ti;
        SIMD_FLOAT Tb, Tt;
        T1            = ri[0];
        T2            = ri[WS(is, 3)];
        Tp            = ii[0];
        Tq            = ii[WS(is, 3)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 5)];
        T7            = ri[WS(is, 4)];
        T8            = ri[WS(is, 1)];
        Tc            = ii[WS(is, 2)];
        Td            = ii[WS(is, 5)];
        Tf            = ii[WS(is, 4)];
        Tg            = ii[WS(is, 1)];
        T3            = T1 - T2;
        Tr            = Tp - Tq;
        T6            = T4 - T5;
        Tj            = T4 + T5;
        T9            = T7 - T8;
        Tk            = T7 + T8;
        Te            = Tc - Td;
        Tm            = Tc + Td;
        Th            = Tf - Tg;
        Tn            = Tf + Tg;
        Tl            = T1 + SIMD_FNMADD(KP500000000, Tj + Tk, T2);
        Tw            = Tk - Tj;
        Ta            = T6 + T9;
        Tu            = T9 - T6;
        To            = Tm - Tn;
        Tv            = Tp + SIMD_FNMADD(KP500000000, Tm + Tn, Tq);
        Ts            = Te + Th;
        Ti            = Te - Th;
        Tb            = SIMD_FNMADD(KP500000000, Ta, T3);
        ro[WS(os, 2)] = T3 + Ta;
        ro[WS(os, 3)] = SIMD_FMADD(KP866025403, To, Tl);
        ro[WS(os, 1)] = SIMD_FNMADD(KP866025403, To, Tl);
        io[WS(os, 3)] = SIMD_FMADD(KP866025403, Tw, Tv);
        io[WS(os, 1)] = SIMD_FNMADD(KP866025403, Tw, Tv);
        Tt            = SIMD_FNMADD(KP500000000, Ts, Tr);
        io[WS(os, 2)] = Ts + Tr;
        ro[0]         = SIMD_FMADD(KP866025403, Ti, Tb);
        ro[WS(os, 4)] = SIMD_FNMADD(KP866025403, Ti, Tb);
        io[WS(os, 4)] = SIMD_FNMADD(KP866025403, Tu, Tt);
        io[0]         = SIMD_FMADD(KP866025403, Tu, Tt);
    }
}

template <>
struct c2cb_traits<6, 2>
{
    static constexpr long_t flops           = 42;
    static constexpr long_t operations      = 32;
    static constexpr long_t memory_accesses = 20;
    static constexpr long_t stack_vars      = 35;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 6 -skip-k 2 -name c2cb
 * -standalone */

/*
 * This function contains 32 FP additions, 10 FP multiplications,
 * (or, 22 additions, 0 multiplications, 10 fused multiply/add),
 * 35 stack variables, 3 constants, and 20 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 6 && SkippedOutputs == 2>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP577350269, +0.577350269189625764509148780501957455647601751);
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    DK(KP500000000, +0.500000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, Tq, Tr, T4, T5, T7, T8, Te, Tf, Th, Ti, T3, Ts, T6;
        SIMD_FLOAT Tb, T9, Tc, Tm, Tg, Tl, Tj, Td, Tw, Ta, Tt, Tk, Tv, Tp, Tn;
        SIMD_FLOAT To, Tu;
        T1            = ri[0];
        T2            = ri[WS(is, 3)];
        Tq            = ii[0];
        Tr            = ii[WS(is, 3)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 5)];
        T7            = ri[WS(is, 4)];
        T8            = ri[WS(is, 1)];
        Te            = ii[WS(is, 2)];
        Tf            = ii[WS(is, 5)];
        Th            = ii[WS(is, 4)];
        Ti            = ii[WS(is, 1)];
        T3            = T1 - T2;
        Ts            = Tq - Tr;
        T6            = T4 - T5;
        Tb            = T4 + T5;
        T9            = T7 - T8;
        Tc            = T7 + T8;
        Tm            = Te - Tf;
        Tg            = Te + Tf;
        Tl            = Th - Ti;
        Tj            = Th + Ti;
        Td            = T1 + SIMD_FNMADD(KP500000000, Tb + Tc, T2);
        Tw            = Tc - Tb;
        Ta            = T6 + T9;
        Tt            = T6 - T9;
        Tk            = Tg - Tj;
        Tv            = Tq + SIMD_FNMADD(KP500000000, Tg + Tj, Tr);
        Tp            = Tm + Tl;
        Tn            = Tl - Tm;
        ro[WS(os, 1)] = T3 + Ta;
        ro[WS(os, 2)] = SIMD_FMADD(KP866025403, Tk, Td);
        ro[0]         = SIMD_FNMADD(KP866025403, Tk, Td);
        io[WS(os, 2)] = SIMD_FMADD(KP866025403, Tw, Tv);
        io[0]         = SIMD_FNMADD(KP866025403, Tw, Tv);
        To            = SIMD_FNMADD(KP577350269, Ta, Tn);
        Tu            = SIMD_FNMADD(KP577350269, Tp, Tt);
        io[WS(os, 1)] = Tp + Ts;
        ro[WS(os, 3)] = SIMD_FMADD(KP866025403, To, T3);
        io[WS(os, 3)] = SIMD_FMADD(KP866025403, Tu, Ts);
    }
}

template <>
struct c2cb_traits<6, 3>
{
    static constexpr long_t flops           = 38;
    static constexpr long_t operations      = 30;
    static constexpr long_t memory_accesses = 18;
    static constexpr long_t stack_vars      = 34;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 6 -skip-k 3 -name c2cb
 * -standalone */

/*
 * This function contains 30 FP additions, 8 FP multiplications,
 * (or, 22 additions, 0 multiplications, 8 fused multiply/add),
 * 34 stack variables, 2 constants, and 18 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 6 && SkippedOutputs == 3>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP577350269, +0.577350269189625764509148780501957455647601751);
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    {
        SIMD_FLOAT T1, T2, Tb, Tc, T4, T5, T7, T8, Tf, Tg, Ti, Tj, T3, Td, T6;
        SIMD_FLOAT Ts, T9, Tt, Th, Tp, Tk, Tq, Tv, Tu, Ta, Te, Tw, Tr, Tl, Tn;
        SIMD_FLOAT To, Tm;
        T1    = ri[0];
        T2    = ri[WS(is, 3)];
        Tb    = ii[0];
        Tc    = ii[WS(is, 3)];
        T4    = ri[WS(is, 2)];
        T5    = ri[WS(is, 5)];
        T7    = ri[WS(is, 4)];
        T8    = ri[WS(is, 1)];
        Tf    = ii[WS(is, 2)];
        Tg    = ii[WS(is, 5)];
        Ti    = ii[WS(is, 4)];
        Tj    = ii[WS(is, 1)];
        T3    = T1 - T2;
        Td    = Tb - Tc;
        T6    = T4 - T5;
        Ts    = T4 + T5;
        T9    = T7 - T8;
        Tt    = T7 + T8;
        Th    = Tf - Tg;
        Tp    = Tf + Tg;
        Tk    = Ti - Tj;
        Tq    = Ti + Tj;
        Tv    = Tt - Ts;
        Tu    = Ts + Tt;
        Ta    = T6 + T9;
        Te    = T6 - T9;
        Tw    = Tp + Tq;
        Tr    = Tp - Tq;
        Tl    = Th + Tk;
        Tn    = Tk - Th;
        ro[0] = T3 + Ta;
        ro[WS(os, 1)] =
            T1 + SIMD_FMADD(KP866025403, SIMD_FNMADD(KP577350269, Tu, Tr), T2);
        io[WS(os, 1)] =
            Tb + SIMD_FMADD(KP866025403, SIMD_FNMADD(KP577350269, Tw, Tv), Tc);
        To            = SIMD_FNMADD(KP577350269, Ta, Tn);
        Tm            = SIMD_FNMADD(KP577350269, Tl, Te);
        io[0]         = Td + Tl;
        ro[WS(os, 2)] = SIMD_FMADD(KP866025403, To, T3);
        io[WS(os, 2)] = SIMD_FMADD(KP866025403, Tm, Td);
    }
}

template <>
struct c2cb_traits<6, 4>
{
    static constexpr long_t flops           = 36;
    static constexpr long_t operations      = 28;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 30;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 6 -skip-k 4 -name c2cb
 * -standalone */

/*
 * This function contains 28 FP additions, 8 FP multiplications,
 * (or, 20 additions, 0 multiplications, 8 fused multiply/add),
 * 30 stack variables, 2 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 6 && SkippedOutputs == 4>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP577350269, +0.577350269189625764509148780501957455647601751);
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    {
        SIMD_FLOAT T1, Tn, T2, Tq, T3, T4, Ta, Tb, T6, T7, Td, Te, T5, Th, Tc;
        SIMD_FLOAT Tl, T8, Ti, Tf, Tk, Tj, Tp, T9, Ts, Tm, To, Tg, Tr;
        T1 = ri[0];
        Tn = ii[0];
        T2 = ri[WS(is, 3)];
        Tq = ii[WS(is, 3)];
        T3 = ii[WS(is, 2)];
        T4 = ii[WS(is, 5)];
        Ta = ri[WS(is, 2)];
        Tb = ri[WS(is, 5)];
        T6 = ii[WS(is, 4)];
        T7 = ii[WS(is, 1)];
        Td = ri[WS(is, 4)];
        Te = ri[WS(is, 1)];
        T5 = T3 + T4;
        Th = T4 - T3;
        Tc = Ta + Tb;
        Tl = Ta - Tb;
        T8 = T6 + T7;
        Ti = T6 - T7;
        Tf = Td + Te;
        Tk = Te - Td;
        Tj = Th + Ti;
        Tp = Th - Ti;
        T9 = T5 - T8;
        Ts = T5 + T8;
        Tm = Tk - Tl;
        To = Tl + Tk;
        Tg = Tc + Tf;
        Tr = Tf - Tc;
        io[WS(os, 1)] =
            SIMD_FMADD(KP866025403, SIMD_FMADD(KP577350269, Tp, To), Tn) - Tq;
        ro[WS(os, 1)] =
            SIMD_FMADD(KP866025403, SIMD_FMADD(KP577350269, Tm, Tj), T1) - T2;
        io[0] =
            Tn + SIMD_FMADD(KP866025403, SIMD_FNMADD(KP577350269, Ts, Tr), Tq);
        ro[0] =
            T1 + SIMD_FMADD(KP866025403, SIMD_FNMADD(KP577350269, Tg, T9), T2);
    }
}

template <>
struct c2cb_traits<6, 5>
{
    static constexpr long_t flops           = 18;
    static constexpr long_t operations      = 14;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 22;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_notwb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 6 -skip-k 5 -name c2cb
 * -standalone */

/*
 * This function contains 14 FP additions, 4 FP multiplications,
 * (or, 10 additions, 0 multiplications, 4 fused multiply/add),
 * 22 stack variables, 2 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 6 && SkippedOutputs == 5>::type
c2cb(SIMD_FLOAT const* __restrict ii, SIMD_FLOAT const* __restrict ri,
     SIMD_FLOAT* __restrict io, SIMD_FLOAT* __restrict ro)
{
    DK(KP577350269, +0.577350269189625764509148780501957455647601751);
    DK(KP866025403, +0.866025403784438646763723170752936183471402627);
    {
        SIMD_FLOAT T1, Th, Tg, Tk, T2, T3, Tc, Td, T5, T6, T9, Ta, T4, Te, T7;
        SIMD_FLOAT Tb, T8, Tj, Tf, Ti;
        T1 = ri[0];
        Th = ii[0];
        Tg = ri[WS(is, 3)];
        Tk = ii[WS(is, 3)];
        T2 = ii[WS(is, 5)];
        T3 = ii[WS(is, 2)];
        Tc = ri[WS(is, 2)];
        Td = ri[WS(is, 5)];
        T5 = ii[WS(is, 4)];
        T6 = ii[WS(is, 1)];
        T9 = ri[WS(is, 1)];
        Ta = ri[WS(is, 4)];
        T4 = T2 - T3;
        Te = Tc - Td;
        T7 = T5 - T6;
        Tb = T9 - Ta;
        T8 = T4 + T7;
        Tj = T4 - T7;
        Tf = Tb - Te;
        Ti = Te + Tb;
        io[0] =
            SIMD_FMADD(KP866025403, SIMD_FMADD(KP577350269, Tj, Ti), Th) - Tk;
        ro[0] =
            SIMD_FMADD(KP866025403, SIMD_FMADD(KP577350269, Tf, T8), T1) - Tg;
    }
}
