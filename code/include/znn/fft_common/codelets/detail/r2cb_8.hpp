//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct r2cb_traits<8, 0>
{
    static constexpr long_t flops           = 32;
    static constexpr long_t operations      = 20;
    static constexpr long_t memory_accesses = 16;
    static constexpr long_t stack_vars      = 22;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 0 -name r2cb
 * -standalone */

/*
 * This function contains 20 FP additions, 12 FP multiplications,
 * (or, 8 additions, 0 multiplications, 12 fused multiply/add),
 * 22 stack variables, 2 constants, and 16 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 0>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_414213562, +1.414213562373095048801688724209698078569671875);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T4, Ta, T1, T2, T6, T7, Td, Te, T3, T9, T8, Tc, Tf, Tk, Tb;
        SIMD_FLOAT Th, T5, Tj, Tg, Ti;
        T4            = Cr[WS(cs, 2)];
        Ta            = Ci[WS(cs, 2)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        T6            = Cr[WS(cs, 1)];
        T7            = Cr[WS(cs, 3)];
        Td            = Ci[WS(cs, 1)];
        Te            = Ci[WS(cs, 3)];
        T3            = T1 + T2;
        T9            = T1 - T2;
        T8            = T6 + T7;
        Tc            = T6 - T7;
        Tf            = Td + Te;
        Tk            = Td - Te;
        Tb            = SIMD_FNMADD(KP2_000000000, Ta, T9);
        Th            = SIMD_FMADD(KP2_000000000, Ta, T9);
        T5            = SIMD_FMADD(KP2_000000000, T4, T3);
        Tj            = SIMD_FNMADD(KP2_000000000, T4, T3);
        Tg            = Tc - Tf;
        Ti            = Tc + Tf;
        R0[WS(rs, 6)] = SIMD_FMADD(KP2_000000000, Tk, Tj);
        R0[WS(rs, 2)] = SIMD_FNMADD(KP2_000000000, Tk, Tj);
        R0[0]         = SIMD_FMADD(KP2_000000000, T8, T5);
        R0[WS(rs, 4)] = SIMD_FNMADD(KP2_000000000, T8, T5);
        R0[WS(rs, 7)] = SIMD_FMADD(KP1_414213562, Ti, Th);
        R0[WS(rs, 3)] = SIMD_FNMADD(KP1_414213562, Ti, Th);
        R0[WS(rs, 1)] = SIMD_FMADD(KP1_414213562, Tg, Tb);
        R0[WS(rs, 5)] = SIMD_FNMADD(KP1_414213562, Tg, Tb);
    }
}

template <>
struct r2cb_traits<8, 1>
{
    static constexpr long_t flops           = 29;
    static constexpr long_t operations      = 19;
    static constexpr long_t memory_accesses = 15;
    static constexpr long_t stack_vars      = 21;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 1 -name r2cb
 * -standalone */

/*
 * This function contains 19 FP additions, 10 FP multiplications,
 * (or, 9 additions, 0 multiplications, 10 fused multiply/add),
 * 21 stack variables, 2 constants, and 15 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 1>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_414213562, +1.414213562373095048801688724209698078569671875);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T4, T9, Ta, T1, T2, T6, Tg, T7, Tb, Ti, T3, Tf, Tj, T8, Th;
        SIMD_FLOAT Td, T5, Tc, Te;
        T4            = Ci[WS(cs, 2)];
        T9            = Ci[WS(cs, 1)];
        Ta            = Ci[WS(cs, 3)];
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        T6            = Cr[WS(cs, 1)];
        Tg            = Cr[WS(cs, 2)];
        T7            = Cr[WS(cs, 3)];
        Tb            = T9 + Ta;
        Ti            = T9 - Ta;
        T3            = T1 - T2;
        Tf            = T1 + T2;
        Tj            = Tg - T7 - T6;
        T8            = T6 - T7;
        Th            = SIMD_FNMADD(KP2_000000000, Tg, Tf);
        Td            = SIMD_FMADD(KP2_000000000, T4, T3);
        T5            = SIMD_FNMADD(KP2_000000000, T4, T3);
        R0[WS(rs, 3)] = SIMD_FMADD(KP2_000000000, Tj, Tf);
        Tc            = T8 - Tb;
        Te            = T8 + Tb;
        R0[WS(rs, 5)] = SIMD_FMADD(KP2_000000000, Ti, Th);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP2_000000000, Ti, Th);
        R0[WS(rs, 6)] = SIMD_FMADD(KP1_414213562, Te, Td);
        R0[WS(rs, 2)] = SIMD_FNMADD(KP1_414213562, Te, Td);
        R0[0]         = SIMD_FMADD(KP1_414213562, Tc, T5);
        R0[WS(rs, 4)] = SIMD_FNMADD(KP1_414213562, Tc, T5);
    }
}

template <>
struct r2cb_traits<8, 2>
{
    static constexpr long_t flops           = 28;
    static constexpr long_t operations      = 18;
    static constexpr long_t memory_accesses = 14;
    static constexpr long_t stack_vars      = 22;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 2 -name r2cb
 * -standalone */

/*
 * This function contains 18 FP additions, 10 FP multiplications,
 * (or, 8 additions, 0 multiplications, 10 fused multiply/add),
 * 22 stack variables, 3 constants, and 14 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 2>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_414213562, +1.414213562373095048801688724209698078569671875);
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, T6, T7, T4, Ta, Tb, Tc, T3, T9, T8, Tf, Tj, Td, Th;
        SIMD_FLOAT T5, Ti, Te, Tg;
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        T6            = Ci[WS(cs, 1)];
        T7            = Ci[WS(cs, 3)];
        T4            = Cr[WS(cs, 2)];
        Ta            = Ci[WS(cs, 2)];
        Tb            = Cr[WS(cs, 1)];
        Tc            = Cr[WS(cs, 3)];
        T3            = T1 + T2;
        T9            = T1 - T2;
        T8            = T6 - T7;
        Tf            = T6 + T7;
        Tj            = T4 - Tc - Tb;
        Td            = Tb - Tc;
        Th            = SIMD_FMADD(KP2_000000000, Ta, T9);
        T5            = SIMD_FNMADD(KP2_000000000, T4, T3);
        R0[WS(rs, 2)] = SIMD_FMADD(KP2_000000000, Tj, T3);
        Ti            = Tf + Td;
        Te            = SIMD_FMADD(KP707106781, Td, Ta);
        R0[WS(rs, 4)] = SIMD_FMADD(KP2_000000000, T8, T5);
        R0[0]         = SIMD_FNMADD(KP2_000000000, T8, T5);
        R0[WS(rs, 5)] = SIMD_FMADD(KP1_414213562, Ti, Th);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP1_414213562, Ti, Th);
        Tg            = SIMD_FNMADD(KP707106781, Tf, Te);
        R0[WS(rs, 3)] = SIMD_FNMADD(KP2_000000000, Tg, T9);
    }
}

template <>
struct r2cb_traits<8, 3>
{
    static constexpr long_t flops           = 25;
    static constexpr long_t operations      = 17;
    static constexpr long_t memory_accesses = 13;
    static constexpr long_t stack_vars      = 21;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 3 -name r2cb
 * -standalone */

/*
 * This function contains 17 FP additions, 8 FP multiplications,
 * (or, 9 additions, 0 multiplications, 8 fused multiply/add),
 * 21 stack variables, 3 constants, and 13 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 3>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP1_414213562, +1.414213562373095048801688724209698078569671875);
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T2, T4, Tg, T9, Ta, T6, T7, T3, Tf, Th, Tb, Ti, T8, T5;
        SIMD_FLOAT Tc, Td, Te;
        T1            = Cr[0];
        T2            = Cr[WS(cs, 4)];
        T4            = Ci[WS(cs, 2)];
        Tg            = Cr[WS(cs, 2)];
        T9            = Ci[WS(cs, 1)];
        Ta            = Ci[WS(cs, 3)];
        T6            = Cr[WS(cs, 1)];
        T7            = Cr[WS(cs, 3)];
        T3            = T1 - T2;
        Tf            = T1 + T2;
        Th            = T9 - (Ta + Tg);
        Tb            = T9 + Ta;
        Ti            = Tg - T7 - T6;
        T8            = T6 - T7;
        T5            = SIMD_FMADD(KP2_000000000, T4, T3);
        R0[WS(rs, 3)] = SIMD_FMADD(KP2_000000000, Th, Tf);
        R0[WS(rs, 1)] = SIMD_FMADD(KP2_000000000, Ti, Tf);
        Tc            = T8 + Tb;
        Td            = SIMD_FMADD(KP707106781, T8, T4);
        R0[WS(rs, 4)] = SIMD_FMADD(KP1_414213562, Tc, T5);
        R0[0]         = SIMD_FNMADD(KP1_414213562, Tc, T5);
        Te            = SIMD_FNMADD(KP707106781, Tb, Td);
        R0[WS(rs, 2)] = SIMD_FNMADD(KP2_000000000, Te, T3);
    }
}

template <>
struct r2cb_traits<8, 4>
{
    static constexpr long_t flops           = 20;
    static constexpr long_t operations      = 14;
    static constexpr long_t memory_accesses = 12;
    static constexpr long_t stack_vars      = 17;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 4 -name r2cb
 * -standalone */

/*
 * This function contains 14 FP additions, 6 FP multiplications,
 * (or, 8 additions, 0 multiplications, 6 fused multiply/add),
 * 17 stack variables, 3 constants, and 12 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 4>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    DK(KP1_414213562, +1.414213562373095048801688724209698078569671875);
    {
        SIMD_FLOAT Tc, T1, T5, T9, T8, T6, T4, T2, Td, Ta, T7, Tb, T3, Te;
        Tc            = Ci[WS(cs, 2)];
        T1            = Cr[0];
        T5            = Cr[WS(cs, 3)];
        T9            = Ci[WS(cs, 3)];
        T8            = Ci[WS(cs, 1)];
        T6            = Cr[WS(cs, 1)];
        T4            = Cr[WS(cs, 2)];
        T2            = Cr[WS(cs, 4)];
        Td            = T6 - T5;
        Ta            = T8 - (T4 + T9);
        T7            = T4 - T5 - T6;
        Tb            = SIMD_FMADD(KP1_414213562, T8 + T9, T1) - T2;
        T3            = T1 + T2;
        Te            = SIMD_FMADD(KP707106781, Td, Tc);
        R0[WS(rs, 2)] = SIMD_FMADD(KP2_000000000, Ta, T3);
        R0[0]         = SIMD_FMADD(KP2_000000000, T7, T3);
        R0[WS(rs, 3)] = SIMD_FMADD(KP2_000000000, Te, Tb);
        R0[WS(rs, 1)] = SIMD_FNMADD(KP2_000000000, Te, Tb);
    }
}

template <>
struct r2cb_traits<8, 5>
{
    static constexpr long_t flops           = 16;
    static constexpr long_t operations      = 11;
    static constexpr long_t memory_accesses = 11;
    static constexpr long_t stack_vars      = 14;
    static constexpr long_t constants       = 3;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 5 -name r2cb
 * -standalone */

/*
 * This function contains 11 FP additions, 5 FP multiplications,
 * (or, 6 additions, 0 multiplications, 5 fused multiply/add),
 * 14 stack variables, 3 constants, and 11 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 5>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    DK(KP1_414213562, +1.414213562373095048801688724209698078569671875);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T6, Tb, T7, T8, T1, T4, T2, T3, T9, T5, Ta;
        T6            = Ci[WS(cs, 2)];
        Tb            = Cr[WS(cs, 2)];
        T7            = Cr[WS(cs, 1)];
        T8            = Cr[WS(cs, 3)];
        T1            = Cr[0];
        T4            = Cr[WS(cs, 4)];
        T2            = Ci[WS(cs, 1)];
        T3            = Ci[WS(cs, 3)];
        T9            = T7 - T8;
        R0[WS(rs, 1)] = T1 + SIMD_FMADD(KP2_000000000, T2 - Tb - T3, T4);
        T5            = SIMD_FMADD(KP1_414213562, T2 + T3, T1) - T4;
        Ta            = SIMD_FMADD(KP707106781, T9, T6);
        R0[WS(rs, 2)] = SIMD_FMADD(KP2_000000000, Ta, T5);
        R0[0]         = SIMD_FNMADD(KP2_000000000, Ta, T5);
    }
}

template <>
struct r2cb_traits<8, 6>
{
    static constexpr long_t flops           = 13;
    static constexpr long_t operations      = 10;
    static constexpr long_t memory_accesses = 10;
    static constexpr long_t stack_vars      = 11;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 6 -name r2cb
 * -standalone */

/*
 * This function contains 10 FP additions, 3 FP multiplications,
 * (or, 7 additions, 0 multiplications, 3 fused multiply/add),
 * 11 stack variables, 2 constants, and 10 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 6>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T6, T5, T2, T3, T7, T4, T8, T9;
        T1    = Cr[0];
        T6    = Ci[WS(cs, 2)];
        T5    = Cr[WS(cs, 2)];
        T2    = Cr[WS(cs, 4)];
        T3    = Ci[WS(cs, 1)];
        T7    = Cr[WS(cs, 1)];
        T4    = Ci[WS(cs, 3)];
        T8    = Cr[WS(cs, 3)];
        R0[0] = T1 + SIMD_FMADD(KP2_000000000, T3 - T4 - T5, T2);
        T9    = (T3 + T4) + (T7 - T8);
        R0[WS(rs, 1)] =
            SIMD_FMADD(KP2_000000000, SIMD_FMADD(KP707106781, T9, T6), T1) - T2;
    }
}

template <>
struct r2cb_traits<8, 7>
{
    static constexpr long_t flops           = 8;
    static constexpr long_t operations      = 6;
    static constexpr long_t memory_accesses = 8;
    static constexpr long_t stack_vars      = 10;
    static constexpr long_t constants       = 2;
};
/* Generated by: ./gen_r2cb.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -sign 1 -n 8 -skip-k 7 -name r2cb
 * -standalone */

/*
 * This function contains 6 FP additions, 2 FP multiplications,
 * (or, 4 additions, 0 multiplications, 2 fused multiply/add),
 * 10 stack variables, 2 constants, and 8 memory accesses
 */
template <long_t TransformSize, long_t SkippedOutputs, long_t rs, long_t cs>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && SkippedOutputs == 7>::type
r2cb(SIMD_FLOAT* __restrict R0, SIMD_FLOAT const* __restrict Cr,
     SIMD_FLOAT const* __restrict Ci)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    DK(KP2_000000000, +2.000000000000000000000000000000000000000000000);
    {
        SIMD_FLOAT T1, T8, T2, T3, T4, T5, T6, T7;
        T1 = Cr[0];
        T8 = Cr[WS(cs, 4)];
        T2 = Ci[WS(cs, 2)];
        T3 = Cr[WS(cs, 1)];
        T4 = Ci[WS(cs, 1)];
        T5 = Ci[WS(cs, 3)];
        T6 = Cr[WS(cs, 3)];
        T7 = T3 + T4 + T5 - T6;
        R0[0] =
            SIMD_FMADD(KP2_000000000, SIMD_FMADD(KP707106781, T7, T2), T1) - T8;
    }
}
