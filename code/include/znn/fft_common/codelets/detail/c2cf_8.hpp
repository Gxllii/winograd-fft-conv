//
// Copyright (C) 2018 Aleksandar Zlateski <zlateski@mit.edu>
// Copyright (C) 2018 Zhen Jia <zhenj@princeton.edu>
// ---------------------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma once
template <>
struct c2cf_traits<8, 1>
{
    static constexpr long_t flops           = 0;
    static constexpr long_t operations      = 0;
    static constexpr long_t memory_accesses = 18;
    static constexpr long_t stack_vars      = 2;
    static constexpr long_t constants       = 0;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 1 -name c2cf
 * -standalone */

/*
 * This function contains 0 FP additions, 0 FP multiplications,
 * (or, 0 additions, 0 multiplications, 0 fused multiply/add),
 * 2 stack variables, 0 constants, and 18 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 1>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    {
        SIMD_FLOAT T1, T2;
        T1            = ri[0];
        T2            = ii[0];
        ro[WS(os, 3)] = T1;
        ro[WS(os, 5)] = T1;
        ro[WS(os, 4)] = T1;
        ro[WS(os, 2)] = T1;
        ro[WS(os, 1)] = T1;
        ro[WS(os, 7)] = T1;
        ro[WS(os, 6)] = T1;
        ro[0]         = T1;
        io[WS(os, 3)] = T2;
        io[WS(os, 5)] = T2;
        io[WS(os, 4)] = T2;
        io[WS(os, 2)] = T2;
        io[WS(os, 1)] = T2;
        io[WS(os, 7)] = T2;
        io[WS(os, 6)] = T2;
        io[0]         = T2;
    }
}

template <>
struct c2cf_traits<8, 2>
{
    static constexpr long_t flops           = 26;
    static constexpr long_t operations      = 18;
    static constexpr long_t memory_accesses = 20;
    static constexpr long_t stack_vars      = 7;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 2 -name c2cf
 * -standalone */

/*
 * This function contains 18 FP additions, 8 FP multiplications,
 * (or, 10 additions, 0 multiplications, 8 fused multiply/add),
 * 7 stack variables, 1 constants, and 20 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 2>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T3, T2, T4, T5, T6;
        T1            = ri[0];
        T3            = ii[0];
        T2            = ri[WS(is, 1)];
        T4            = ii[WS(is, 1)];
        io[WS(os, 6)] = T2 + T3;
        io[WS(os, 2)] = T3 - T2;
        ro[0]         = T1 + T2;
        ro[WS(os, 4)] = T1 - T2;
        ro[WS(os, 6)] = T1 - T4;
        ro[WS(os, 2)] = T1 + T4;
        io[0]         = T3 + T4;
        io[WS(os, 4)] = T3 - T4;
        T5            = T2 + T4;
        T6            = T4 - T2;
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, T6, T1);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, T6, T3);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, T6, T3);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, T6, T1);
        io[WS(os, 7)] = SIMD_FMADD(KP707106781, T5, T3);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, T5, T1);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, T5, T1);
        io[WS(os, 3)] = SIMD_FNMADD(KP707106781, T5, T3);
    }
}

template <>
struct c2cf_traits<8, 3>
{
    static constexpr long_t flops           = 34;
    static constexpr long_t operations      = 26;
    static constexpr long_t memory_accesses = 22;
    static constexpr long_t stack_vars      = 17;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 3 -name c2cf
 * -standalone */

/*
 * This function contains 26 FP additions, 8 FP multiplications,
 * (or, 18 additions, 0 multiplications, 8 fused multiply/add),
 * 17 stack variables, 1 constants, and 22 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 3>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T4, T9, T1, T5, T2, T6, Tc, Tf, T3, Ta, Tb, Te, Tg, Td, T8;
        SIMD_FLOAT T7;
        T4            = ri[WS(is, 1)];
        T9            = ii[WS(is, 1)];
        T1            = ri[0];
        T5            = ii[0];
        T2            = ri[WS(is, 2)];
        T6            = ii[WS(is, 2)];
        Tc            = T4 + T9;
        Tf            = T9 - T4;
        T3            = T1 + T2;
        Ta            = T1 - T2;
        Tb            = T2 + T5;
        Te            = T5 - T2;
        Tg            = T1 - T6;
        Td            = T1 + T6;
        T8            = T5 + T6;
        T7            = T5 - T6;
        ro[WS(os, 6)] = Ta - T9;
        ro[WS(os, 2)] = Ta + T9;
        io[WS(os, 7)] = SIMD_FMADD(KP707106781, Tc, Tb);
        io[WS(os, 3)] = SIMD_FNMADD(KP707106781, Tc, Tb);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, Tf, Te);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tf, Te);
        ro[0]         = T3 + T4;
        ro[WS(os, 4)] = T3 - T4;
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, Tc, Td);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tc, Td);
        io[0]         = T8 + T9;
        io[WS(os, 4)] = T8 - T9;
        io[WS(os, 6)] = T4 + T7;
        io[WS(os, 2)] = T7 - T4;
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, Tf, Tg);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, Tf, Tg);
    }
}

template <>
struct c2cf_traits<8, 4>
{
    static constexpr long_t flops           = 44;
    static constexpr long_t operations      = 36;
    static constexpr long_t memory_accesses = 24;
    static constexpr long_t stack_vars      = 29;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 4 -name c2cf
 * -standalone */

/*
 * This function contains 36 FP additions, 8 FP multiplications,
 * (or, 28 additions, 0 multiplications, 8 fused multiply/add),
 * 29 stack variables, 1 constants, and 24 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 4>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T1, T8, T2, T9, T4, Tc, T5, Td, Tn, Tl, Tb, T3, Ta, Tf, Th;
        SIMD_FLOAT Tr, To, Ti, T6, T7, Te, Tg, Tj, Tp, Tk, Tm, Tq, Ts;
        T1            = ri[0];
        T8            = ii[0];
        T2            = ri[WS(is, 2)];
        T9            = ii[WS(is, 2)];
        T4            = ri[WS(is, 1)];
        Tc            = ii[WS(is, 1)];
        T5            = ri[WS(is, 3)];
        Td            = ii[WS(is, 3)];
        Tn            = T8 - T2;
        Tl            = T2 + T8;
        Tb            = T1 - T2;
        T3            = T1 + T2;
        Ta            = T8 - T9;
        Tf            = T8 + T9;
        Th            = T1 + T9;
        Tr            = T1 - T9;
        To            = Tc - T4;
        Ti            = T4 + Tc;
        T6            = T4 + T5;
        T7            = T5 - T4;
        Te            = Tc - Td;
        Tg            = Tc + Td;
        Tj            = Td - T5;
        Tp            = T5 + Td;
        io[WS(os, 6)] = Ta - T7;
        io[WS(os, 2)] = T7 + Ta;
        ro[0]         = T3 + T6;
        ro[WS(os, 4)] = T3 - T6;
        io[0]         = Tf + Tg;
        io[WS(os, 4)] = Tf - Tg;
        Tk            = Ti + Tj;
        Tm            = Tj - Ti;
        ro[WS(os, 6)] = Tb - Te;
        ro[WS(os, 2)] = Tb + Te;
        Tq            = To - Tp;
        Ts            = To + Tp;
        io[WS(os, 3)] = SIMD_FMADD(KP707106781, Tm, Tl);
        io[WS(os, 7)] = SIMD_FNMADD(KP707106781, Tm, Tl);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, Tk, Th);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tk, Th);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, Ts, Tr);
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, Ts, Tr);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, Tq, Tn);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tq, Tn);
    }
}

template <>
struct c2cf_traits<8, 5>
{
    static constexpr long_t flops           = 48;
    static constexpr long_t operations      = 40;
    static constexpr long_t memory_accesses = 26;
    static constexpr long_t stack_vars      = 35;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 5 -name c2cf
 * -standalone */

/*
 * This function contains 40 FP additions, 8 FP multiplications,
 * (or, 32 additions, 0 multiplications, 8 fused multiply/add),
 * 35 stack variables, 1 constants, and 26 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 5>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T4, Td, T1, T2, Ta, Tb, T6, Tg, T7, Th, Tu, Tn, T8, T9, Ti;
        SIMD_FLOAT Tk, To, Tv, Tm, Tx, T5, Tf, Tt, Tr, Tj, Te, T3, Tl, Tc, Tq;
        SIMD_FLOAT Tp, Ts, Tw, Ty;
        T4            = ri[WS(is, 2)];
        Td            = ii[WS(is, 2)];
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Ta            = ii[0];
        Tb            = ii[WS(is, 4)];
        T6            = ri[WS(is, 1)];
        Tg            = ii[WS(is, 1)];
        T7            = ri[WS(is, 3)];
        Th            = ii[WS(is, 3)];
        T3            = T1 + T2;
        Tl            = T1 - T2;
        Tc            = Ta + Tb;
        Tq            = Ta - Tb;
        Tu            = Tg - T6;
        Tn            = T6 + Tg;
        T8            = T6 + T7;
        T9            = T7 - T6;
        Ti            = Tg - Th;
        Tk            = Tg + Th;
        To            = Th - T7;
        Tv            = T7 + Th;
        Tm            = Tl + Td;
        Tx            = Tl - Td;
        T5            = T3 + T4;
        Tf            = T3 - T4;
        Tt            = Tq - T4;
        Tr            = T4 + Tq;
        Tj            = Tc + Td;
        Te            = Tc - Td;
        Tp            = Tn + To;
        Ts            = To - Tn;
        Tw            = Tu - Tv;
        Ty            = Tu + Tv;
        ro[WS(os, 2)] = Tf + Ti;
        ro[WS(os, 6)] = Tf - Ti;
        ro[0]         = T5 + T8;
        ro[WS(os, 4)] = T5 - T8;
        io[WS(os, 6)] = Te - T9;
        io[WS(os, 2)] = T9 + Te;
        io[0]         = Tj + Tk;
        io[WS(os, 4)] = Tj - Tk;
        io[WS(os, 3)] = SIMD_FMADD(KP707106781, Ts, Tr);
        io[WS(os, 7)] = SIMD_FNMADD(KP707106781, Ts, Tr);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, Tp, Tm);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tp, Tm);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, Ty, Tx);
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, Ty, Tx);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, Tw, Tt);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tw, Tt);
    }
}

template <>
struct c2cf_traits<8, 6>
{
    static constexpr long_t flops           = 52;
    static constexpr long_t operations      = 44;
    static constexpr long_t memory_accesses = 28;
    static constexpr long_t stack_vars      = 41;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 6 -name c2cf
 * -standalone */

/*
 * This function contains 44 FP additions, 8 FP multiplications,
 * (or, 36 additions, 0 multiplications, 8 fused multiply/add),
 * 41 stack variables, 1 constants, and 28 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 6>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T4, Tf, T1, T2, Tc, Td, T9, Tl, T6, T7, Ti, Tj, T3, Tp, Te;
        SIMD_FLOAT Tw, Tu, TB, Tr, T8, Ts, Tk, Tq, TD, T5, Th, Tz, Tx, Tn, Tg;
        SIMD_FLOAT Ta, Tb, To, Tm, TA, Tt, Tv, Ty, TC, TE;
        T4            = ri[WS(is, 2)];
        Tf            = ii[WS(is, 2)];
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tc            = ii[0];
        Td            = ii[WS(is, 4)];
        T9            = ri[WS(is, 3)];
        Tl            = ii[WS(is, 3)];
        T6            = ri[WS(is, 1)];
        T7            = ri[WS(is, 5)];
        Ti            = ii[WS(is, 1)];
        Tj            = ii[WS(is, 5)];
        T3            = T1 + T2;
        Tp            = T1 - T2;
        Te            = Tc + Td;
        Tw            = Tc - Td;
        Tu            = Tl - T9;
        TB            = T9 + Tl;
        Tr            = T6 - T7;
        T8            = T6 + T7;
        Ts            = Ti - Tj;
        Tk            = Ti + Tj;
        Tq            = Tp + Tf;
        TD            = Tp - Tf;
        T5            = T3 + T4;
        Th            = T3 - T4;
        Tz            = Tw - T4;
        Tx            = T4 + Tw;
        Tn            = Te + Tf;
        Tg            = Te - Tf;
        Ta            = T8 + T9;
        Tb            = T9 - T8;
        To            = Tk + Tl;
        Tm            = Tk - Tl;
        TA            = Ts - Tr;
        Tt            = Tr + Ts;
        io[WS(os, 6)] = Tg - Tb;
        io[WS(os, 2)] = Tb + Tg;
        ro[0]         = T5 + Ta;
        ro[WS(os, 4)] = T5 - Ta;
        ro[WS(os, 2)] = Th + Tm;
        ro[WS(os, 6)] = Th - Tm;
        io[0]         = Tn + To;
        io[WS(os, 4)] = Tn - To;
        Tv            = Tt + Tu;
        Ty            = Tu - Tt;
        TC            = TA - TB;
        TE            = TA + TB;
        io[WS(os, 3)] = SIMD_FMADD(KP707106781, Ty, Tx);
        io[WS(os, 7)] = SIMD_FNMADD(KP707106781, Ty, Tx);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, Tv, Tq);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, Tv, Tq);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, TE, TD);
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, TE, TD);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, TC, Tz);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, TC, Tz);
    }
}

template <>
struct c2cf_traits<8, 7>
{
    static constexpr long_t flops           = 56;
    static constexpr long_t operations      = 48;
    static constexpr long_t memory_accesses = 30;
    static constexpr long_t stack_vars      = 47;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 7 -name c2cf
 * -standalone */

/*
 * This function contains 48 FP additions, 8 FP multiplications,
 * (or, 40 additions, 0 multiplications, 8 fused multiply/add),
 * 47 stack variables, 1 constants, and 30 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 7>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT Tb, Tp, Tm, Tt, T3, TC, Tg, TB, T6, Tu, Tj, TH, Tz, Tw, Ta;
        SIMD_FLOAT Tn, T1, T2, Te, Tf, T4, T5, Th, Ti, T8, T9, TF, TD, T7, Tl;
        SIMD_FLOAT Tv, TJ, Tr, Tk, Tx, To, Tc, Td, Ts, Tq, TG, Ty, TA, TE, TI;
        SIMD_FLOAT TK;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Te            = ii[0];
        Tf            = ii[WS(is, 4)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 6)];
        Th            = ii[WS(is, 2)];
        Ti            = ii[WS(is, 6)];
        Tb            = ri[WS(is, 3)];
        Tp            = ii[WS(is, 3)];
        T8            = ri[WS(is, 1)];
        T9            = ri[WS(is, 5)];
        Tm            = ii[WS(is, 1)];
        Tt            = T1 - T2;
        T3            = T1 + T2;
        TC            = Te - Tf;
        Tg            = Te + Tf;
        TB            = T4 - T5;
        T6            = T4 + T5;
        Tu            = Th - Ti;
        Tj            = Th + Ti;
        TH            = Tb + Tp;
        Tz            = Tp - Tb;
        Tw            = T8 - T9;
        Ta            = T8 + T9;
        Tn            = ii[WS(is, 5)];
        TF            = TC - TB;
        TD            = TB + TC;
        T7            = T3 + T6;
        Tl            = T3 - T6;
        Tv            = Tt + Tu;
        TJ            = Tt - Tu;
        Tr            = Tg + Tj;
        Tk            = Tg - Tj;
        Tx            = Tm - Tn;
        To            = Tm + Tn;
        Tc            = Ta + Tb;
        Td            = Tb - Ta;
        Ts            = To + Tp;
        Tq            = To - Tp;
        TG            = Tx - Tw;
        Ty            = Tw + Tx;
        io[WS(os, 6)] = Tk - Td;
        io[WS(os, 2)] = Td + Tk;
        ro[0]         = T7 + Tc;
        ro[WS(os, 4)] = T7 - Tc;
        ro[WS(os, 2)] = Tl + Tq;
        ro[WS(os, 6)] = Tl - Tq;
        io[0]         = Tr + Ts;
        io[WS(os, 4)] = Tr - Ts;
        TA            = Ty + Tz;
        TE            = Tz - Ty;
        TI            = TG - TH;
        TK            = TG + TH;
        io[WS(os, 3)] = SIMD_FMADD(KP707106781, TE, TD);
        io[WS(os, 7)] = SIMD_FNMADD(KP707106781, TE, TD);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, TA, Tv);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, TA, Tv);
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, TK, TJ);
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, TK, TJ);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, TI, TF);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, TI, TF);
    }
}

template <>
struct c2cf_traits<8, 8>
{
    static constexpr long_t flops           = 60;
    static constexpr long_t operations      = 52;
    static constexpr long_t memory_accesses = 32;
    static constexpr long_t stack_vars      = 53;
    static constexpr long_t constants       = 1;
};
/* Generated by: ./gen_notwf.native -fma -reorder-insns -schedule-for-pipeline
 * -compact -variables 30 -pipeline-latency 12 -n 8 -first-k 8 -name c2cf
 * -standalone */

/*
 * This function contains 52 FP additions, 8 FP multiplications,
 * (or, 44 additions, 0 multiplications, 8 fused multiply/add),
 * 53 stack variables, 1 constants, and 32 memory accesses
 */
template <long_t TransformSize, long_t ProvidedElements, long_t is, long_t os>
inline __attribute__((always_inline))
typename std::enable_if<TransformSize == 8 && ProvidedElements == 8>::type
c2cf(SIMD_FLOAT const* __restrict ri, SIMD_FLOAT const* __restrict ii,
     SIMD_FLOAT* __restrict ro, SIMD_FLOAT* __restrict io)
{
    DK(KP707106781, +0.707106781186547524400844362104849039284835938);
    {
        SIMD_FLOAT T8, Tn, T3, TC, Ti, TB, T6, To, Tl, Td, Tv, TN, Ty, T9, Tr;
        SIMD_FLOAT Ts, T1, T2, Tg, Th, T4, T5, Tj, Tk, Tb, Tc, Tw, Tx, TJ, TD;
        SIMD_FLOAT T7, TL, Tp, TF, TP, Tm, Tz, TH, Tq, Ta, Tt, TM, Te, Tf, TQ;
        SIMD_FLOAT TO, Tu, TG, TK, TI, TA, TE;
        T1            = ri[0];
        T2            = ri[WS(is, 4)];
        Tg            = ii[0];
        Th            = ii[WS(is, 4)];
        T4            = ri[WS(is, 2)];
        T5            = ri[WS(is, 6)];
        Tj            = ii[WS(is, 2)];
        Tk            = ii[WS(is, 6)];
        Tb            = ri[WS(is, 7)];
        Tc            = ri[WS(is, 3)];
        Tw            = ii[WS(is, 7)];
        Tx            = ii[WS(is, 3)];
        T8            = ri[WS(is, 1)];
        Tn            = T1 - T2;
        T3            = T1 + T2;
        TC            = Tg - Th;
        Ti            = Tg + Th;
        TB            = T4 - T5;
        T6            = T4 + T5;
        To            = Tj - Tk;
        Tl            = Tj + Tk;
        Td            = Tb + Tc;
        Tv            = Tb - Tc;
        TN            = Tw + Tx;
        Ty            = Tw - Tx;
        T9            = ri[WS(is, 5)];
        Tr            = ii[WS(is, 1)];
        Ts            = ii[WS(is, 5)];
        TJ            = TC - TB;
        TD            = TB + TC;
        T7            = T3 + T6;
        TL            = T3 - T6;
        Tp            = Tn + To;
        TF            = Tn - To;
        TP            = Ti + Tl;
        Tm            = Ti - Tl;
        Tz            = Tv - Ty;
        TH            = Tv + Ty;
        Tq            = T8 - T9;
        Ta            = T8 + T9;
        Tt            = Tr - Ts;
        TM            = Tr + Ts;
        Te            = Ta + Td;
        Tf            = Td - Ta;
        TQ            = TM + TN;
        TO            = TM - TN;
        Tu            = Tq + Tt;
        TG            = Tt - Tq;
        io[WS(os, 6)] = Tm - Tf;
        io[WS(os, 2)] = Tf + Tm;
        ro[0]         = T7 + Te;
        ro[WS(os, 4)] = T7 - Te;
        ro[WS(os, 2)] = TL + TO;
        ro[WS(os, 6)] = TL - TO;
        io[0]         = TP + TQ;
        io[WS(os, 4)] = TP - TQ;
        TK            = TG + TH;
        TI            = TG - TH;
        TA            = Tu + Tz;
        TE            = Tz - Tu;
        ro[WS(os, 3)] = SIMD_FMADD(KP707106781, TI, TF);
        ro[WS(os, 7)] = SIMD_FNMADD(KP707106781, TI, TF);
        io[WS(os, 1)] = SIMD_FMADD(KP707106781, TK, TJ);
        io[WS(os, 5)] = SIMD_FNMADD(KP707106781, TK, TJ);
        io[WS(os, 3)] = SIMD_FMADD(KP707106781, TE, TD);
        io[WS(os, 7)] = SIMD_FNMADD(KP707106781, TE, TD);
        ro[WS(os, 1)] = SIMD_FMADD(KP707106781, TA, Tp);
        ro[WS(os, 5)] = SIMD_FNMADD(KP707106781, TA, Tp);
    }
}
